<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <title>Âù¶ÂÖãÂØπÊàòÊ∏∏Êàè</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            touch-action: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        #canvas {
            display: block;
            background-color: #000;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            display: none;
        }

        #gameMessage {
            text-align: center;
            color: white;
            background: rgba(20, 30, 48, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #4cc9f0;
            box-shadow: 0 0 40px rgba(76, 201, 240, 0.5);
            max-width: 80%;
        }

        #gameMessage h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #fad0c4, #a1c4fd);
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }

        #restartButton {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
            font-weight: bold;
            letter-spacing: 1px;
        }

        #restartButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.8);
        }

        #restartButton:active {
            transform: scale(0.95);
        }

        /* ‰øÆÊîπÔºöÂçÅÂ≠óÊñπÂêëÈîÆÊ†∑Âºè */
        #joystickArea {
            position: fixed;
            left: 5vw;
            bottom: 5vw;
            width: 25vw;
            height: 25vw;
            max-width: 30vh;
            max-height: 30vh;
            z-index: 100;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            opacity: 0.7;
        }

        .dpad-button {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.2s;
        }

        .dpad-button.active {
            background: rgba(76, 201, 240, 0.6);
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.8);
        }

        #dpad-up {
            grid-column: 2;
            grid-row: 1;
        }

        #dpad-left {
            grid-column: 1;
            grid-row: 2;
        }

        #dpad-center {
            grid-column: 2;
            grid-row: 2;
            background: transparent;
            border: none;
        }

        #dpad-right {
            grid-column: 3;
            grid-row: 2;
        }

        #dpad-down {
            grid-column: 2;
            grid-row: 3;
        }

        #fireButton {
            position: fixed;
            right: 6vw;
            bottom: 6vw;
            width: 20vw;
            height: 20vw;
            max-width: 25vh;
            max-height: 25vh;
            border-radius: 50%;
            background: rgba(255, 80, 80, 0.2);
            z-index: 100;
            border: 2px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            opacity: 0.7;
        }

        #fireButton.active {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.8);
        }

        #gameTitle {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(77, 211, 248, 0.5);
            font-size: 36px;
            text-shadow: 0 0 15px rgba(76, 201, 240, 0.7);
            z-index: 10;
            font-weight: bold;
            letter-spacing: 2px;
            animation: titleGlow 2s infinite alternate;
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 15px rgba(76, 201, 240, 0.7);
            }

            100% {
                text-shadow: 0 0 25px rgba(76, 201, 240, 1), 0 0 35px rgba(76, 201, 240, 0.8);
            }
        }

        #statusBar {
            position: absolute;
            top: 80px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 10;
            font-size: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            z-index: 15;
            display: none;
        }

        #pauseMessage {
            color: white;
            font-size: 48px;
            text-align: center;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #soundToggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 768px) {
            #instructions {
                font-size: 12px;
                bottom: 100px;
                padding: 6px 12px;
            }

            #gameTitle {
                font-size: 28px;
                top: 15px;
            }

            #statusBar {
                top: 65px;
                font-size: 14px;
                padding: 6px 12px;
            }
        }
    </style>
</head>

<body>
    <div id="gameTitle">üö© Âù¶ÂÖãÂ§ßÊàò üö©</div>
    <canvas id="canvas"></canvas>
    <div id="instructions">
        ÊñπÂêëÈîÆÁßªÂä® | Á©∫Ê†ºÈîÆÂ∞ÑÂáª | ESCÊöÇÂÅú
    </div>
    <div id="statusBar">ÁîüÂëΩ: 5 | Êïå‰∫∫: 10 | BOSSÁîüÂëΩ: 2</div>

    <div id="gameOverlay">
        <div id="gameMessage">
            <h1 id="messageText">Ê∏∏ÊàèÁªìÊùü</h1>
            <button id="restartButton">ÂÜçÁé©‰∏ÄÊ¨°</button>
        </div>
    </div>

    <div id="pauseOverlay">
        <div id="pauseMessage">Ê∏∏ÊàèÊöÇÂÅú<br><small>ÊåâESCÁªßÁª≠</small></div>
    </div>

    <!-- ‰øÆÊîπÔºöÂçÅÂ≠óÊñπÂêëÈîÆ -->
    <div id="joystickArea">
        <div id="dpad-up" class="dpad-button">‚Üë</div>
        <div id="dpad-left" class="dpad-button">‚Üê</div>
        <div id="dpad-center" class="dpad-button"></div>
        <div id="dpad-right" class="dpad-button">‚Üí</div>
        <div id="dpad-down" class="dpad-button">‚Üì</div>
    </div>
    <div id="fireButton"></div>
    <div id="soundToggle">üîä</div>

    <script>
        // Â∏ßÁéáÊéßÂà∂ (80Hz)
        const targetFPS = 80;
        const frameInterval = 1000 / targetFPS;
        let lastFrameTime = 0;
        let gamePaused = false;

        // Ê∏∏ÊàèÂü∫Êú¨ÂèÇÊï∞Â∏∏Èáè
        const ENEMY_TANK_LIFE = 2;
        const ENEMY_TANK_SPEED = 3;
        const ENEMY_TANK_AMOUNT = 10;
        const ENEMY_TANK_BULLET_SPEED = 6;
        const MYTANK_BULLET_SPEED = 8;
        const MYTANK_SPEED = 4;
        const MYTANK_LIFE = 5;
        const BOSS_LIFE = 2;
        const BRICK_LIFE = 3;
        const STEEL_LIFE = 9;
        const RIVER_LIFE = 999; // Ê≤≥ÈÅì‰∏çÂèØÊëßÊØÅ

        //ÈÖçËâ≤Â∏∏Èáè
        const myBullet_color = "yellow";
        const enemyBullets_color = "red";

        // Á†ñÂùóÁ±ªÂûãÂ∏∏Èáè
        const BRICK_TYPE_STEEL = 1; // Èí¢Á†ñÁ±ªÂûã
        const BRICK_TYPE_EARTH = 2; // ÂúüÁ†ñÁ±ªÂûã
        const BRICK_TYPE_RIVER = 3; // Ê≤≥ÈÅìÁ±ªÂûã

        // Èü≥ÊïàÂ∏∏Èáè
        const SOUND_TANK_HIT = 0;
        const SOUND_TANK_EXPLOSION = 1;
        const SOUND_BRICK_HIT = 2;
        const SOUND_BRICK_EXPLOSION = 3;
        const SOUND_STEEL_HIT = 4;
        const SOUND_STEEL_EXPLOSION = 5;
        const SOUND_SHOOT = 6;

        // Èü≥ÊïàÁä∂ÊÄÅ
        let soundEnabled = true;
        let audioContext = null;
        let brickExplosionGif = null;

        // ÂõæÁâáÂØπË±°
        const images = {
            enemyTank: {
                UP: null,
                DOWN: null,
                LEFT: null,
                RIGHT: null
            },
            myTank: {
                UP: null,
                DOWN: null,
                LEFT: null,
                RIGHT: null
            },
            bricks: null,
            steels: null,
            river: null, // Ê≤≥ÈÅìÂõæÁâá
            boss: null,
            blast: []
        };

        //ÂõæÁâáÁΩëÂùÄËµÑÊ∫ê
        const url_enemyTank1_UP = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_UP.png';
        const url_enemyTank1_DOWN = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_DOWN.png';
        const url_enemyTank1_LEFT = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_LEFT.png';
        const url_enemyTank1_RIGHT = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_RIGHT.png';
        const url_myTank_UP = 'https://uy.wzznft.com/i/2025/08/10/mytank2_UP.png';
        const url_myTank_DOWN = 'https://uy.wzznft.com/i/2025/08/10/mytank2_DOWN.png';
        const url_myTank_LEFT = 'https://uy.wzznft.com/i/2025/08/10/mytank2_LEFT.png';
        const url_myTank_RIGHT = 'https://uy.wzznft.com/i/2025/08/10/mytank2_RIGHT.png';
        const url_bricks = 'https://uy.wzznft.com/i/2025/08/10/bricks.png';
        const url_steels = 'https://uy.wzznft.com/i/2025/08/10/steels.png';
        const url_river = 'https://uy.wzznft.com/i/2025/08/11/river.png';
        const url_boss = 'https://uy.wzznft.com/i/2025/08/10/boss.png';
        const url_brickExplosionGif = 'https://uy.wzznft.com/i/2025/08/13/brick_explosion_1.gif';

        //loadImage(url_brickExplosionGif).then(img => brickExplosionGif = img);
        // È¢ÑÂä†ËΩΩÂõæÁâá
        function loadImages() {
            const promises = [];

            // ÊïåÊñπÂù¶ÂÖãÂõæÁâá
            promises.push(loadImage(url_enemyTank1_UP).then(img => images.enemyTank.UP = img));
            promises.push(loadImage(url_enemyTank1_DOWN).then(img => images.enemyTank.DOWN = img));
            promises.push(loadImage(url_enemyTank1_LEFT).then(img => images.enemyTank.LEFT = img));
            promises.push(loadImage(url_enemyTank1_RIGHT).then(img => images.enemyTank.RIGHT = img));

            // ÊàëÊñπÂù¶ÂÖãÂõæÁâá
            promises.push(loadImage(url_myTank_UP).then(img => images.myTank.UP = img));
            promises.push(loadImage(url_myTank_DOWN).then(img => images.myTank.DOWN = img));
            promises.push(loadImage(url_myTank_LEFT).then(img => images.myTank.LEFT = img));
            promises.push(loadImage(url_myTank_RIGHT).then(img => images.myTank.RIGHT = img));

            // Á†ñÂ¢ôÈí¢Â¢ôÂõæÁâá
            promises.push(loadImage(url_bricks).then(img => images.bricks = img));
            promises.push(loadImage(url_steels).then(img => images.steels = img));

            // Ê≤≥ÈÅìÂõæÁâá
            promises.push(loadImage(url_river).then(img => images.river = img));

            // BOSSÂõæÁâá
            promises.push(loadImage(url_boss).then(img => images.boss = img));

            // Á†ñÂùóÁàÜÁÇ∏GIF
            promises.push(loadImage(url_brickExplosionGif).then(img => brickExplosionGif = img));

            // ÁàÜÁÇ∏Âä®ÁîªÂõæÁâá
            for (let i = -1; i < 4; i++) {//ÂÖ±5Â∏ßÔºåÂêçÁß∞ÂêéÁºÄ‰ªé-1~3
                promises.push(loadImage(`https://uy.wzznft.com/i/2025/08/10/blast${i}.png`).then(img => {
                    images.blast.push(img);
                }));
            }

            return Promise.all(promises);
        }
        //ËΩΩÂÖ•ÁΩëÂùÄÂõæÁâá
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        // Á†ñÂùóÁ±ªÂÆö‰πâÔºàÂê´Ê≤≥ÈÅìÔºâ
        class Brick {
            constructor(left, top, type) {
                this.left = left;
                this.top = top;
                this.width = 40;
                this.height = 40;
                this.type = type;//Â¢ô‰ΩìÁ±ªÂûã
                this.life = type == BRICK_TYPE_STEEL ? STEEL_LIFE :
                    type == BRICK_TYPE_RIVER ? RIVER_LIFE : BRICK_LIFE;
                this.hitEffect = 0;//Ë¢´Âáª‰∏≠Êó∂ÁöÑËßÜËßâÊïàÊûúÂ∏ßÊï∞
            }

            draw() {// Âáª‰∏≠ÊïàÊûú                
                if (this.type != BRICK_TYPE_RIVER) {//ÈùûÊ≤≥ÈÅì
                    if (this.hitEffect > 0) {
                        ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';//Ë¢´Âáª‰∏≠ÂêéÁöÑÁ∫¢Ëâ≤Èó™ÂÖâ
                        ctx.shadowBlur = 20;//Èó™ÂÖâÈò¥ÂΩ±ÁöÑÂ§ßÂ∞è
                        this.hitEffect--;//ÁâπÊïàÂ∏ßÊï∞
                    }
                }

                // ÁªòÂà∂Á†ñÂùóÂõæÁâá
                let img;
                if (this.type === BRICK_TYPE_STEEL) {
                    img = images.steels;
                } else if (this.type === BRICK_TYPE_RIVER) {
                    img = images.river;
                } else {
                    img = images.bricks;
                }
                if (img) {
                    ctx.drawImage(img, this.left, this.top, this.width, this.height);
                }

                ctx.shadowBlur = 0;
            }

            hit() {
                if (this.type == BRICK_TYPE_RIVER) return; // ÂøΩÁï•Ê≤≥ÈÅì‰∏éÂ≠êÂºπÁ¢∞Êíû
                this.hitEffect = 5;
                this.life--;
            }
        }
        //Â≠êÂºπÁ±ª
        class Bullet {
            constructor(tank) {
                this.x = tank.gun_pos_x;//Âù¶ÂÖãÁÇÆÂè£‰ΩçÁΩÆ
                this.y = tank.gun_pos_y;
                this.direction = tank.direction;
                this.speed = tank instanceof myTank ? MYTANK_BULLET_SPEED : ENEMY_TANK_BULLET_SPEED;
                this.life = true;
                this.radius = 4;
                this.color = tank instanceof myTank ? myBullet_color : enemyBullets_color;
            }

            draw() {
                if (!this.life) return;

                // ÁªòÂà∂Â≠êÂºπ
                ctx.beginPath();
                ctx.fillStyle = this.color;
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            move() {
                if (!this.life) return;
                switch (this.direction) {
                    case "L": this.x -= this.speed; break;
                    case "R": this.x += this.speed; break;
                    case "U": this.y -= this.speed; break;
                    case "D": this.y += this.speed; break;
                }
                if (this.x < 0 || this.x > canvas.width ||
                    this.y < 0 || this.y > canvas.height) {
                    this.life = false;
                }
            }
        }
        //ÁàÜÁÇ∏‰∫ã‰ª∂Á±ªÔºàÂä®ÁîªÔºâ
        class Explosion {
            constructor(x, y, isBrick = false) {
                this.x = x;
                this.y = y;
                this.frame = 0;
                this.lastFrameTime = Date.now();
                this.frameDelay = 100;
                this.width = 70;
                this.height = 70;
                this.active = true;
                this.isBrick = isBrick;
                this.gifImg = null;
                this.gifTimeout = null;
            }

            draw() {
                if (!this.active) return;
                if (this.isBrick && brickExplosionGif) {
                    if (!this.gifImg) {
                        // ÂàõÂª∫GIFÂõæÁâáÂπ∂ÂÆö‰ΩçÂà∞ÁàÜÁÇ∏‰ΩçÁΩÆ
                        this.gifImg = document.createElement('img');
                        this.gifImg.src = brickExplosionGif.src;
                        this.gifImg.style.position = 'absolute';
                        this.gifImg.style.left = (this.x - this.width / 2) + 'px';
                        this.gifImg.style.top = (this.y - this.height / 2) + 'px';
                        this.gifImg.style.width = this.width + 'px';
                        this.gifImg.style.height = this.height + 'px';
                        this.gifImg.style.pointerEvents = 'none';
                        this.gifImg.style.zIndex = 999;
                        document.body.appendChild(this.gifImg);

                        // Âä®ÁîªÁªìÊùüÂêéÁßªÈô§GIFÂõæÁâá
                        this.gifTimeout = setTimeout(() => {
                            if (this.gifImg) {
                                document.body.removeChild(this.gifImg);
                                this.gifImg = null;
                            }
                            this.active = false;
                        }, 1000); // GIFÂä®ÁîªÊó∂ÈïøÔºàÂª∫ËÆÆÂíåGIFÈïøÂ∫¶‰∏ÄËá¥Ôºâ
                    }
                } else {
                    // ÂéüÊúâÁàÜÁÇ∏Â∏ßÂä®Áîª
                    const img = images.blast[this.frame];
                    if (img) {
                        ctx.drawImage(img, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    }
                }
            }

            update() {
                if (!this.active) return;
                if (this.isBrick && brickExplosionGif) return; // GIFÂä®Áîª‰∏çÈúÄË¶ÅÈÄêÂ∏ß
                const now = Date.now();
                if (now - this.lastFrameTime > this.frameDelay) {
                    this.frame++;
                    this.lastFrameTime = now;
                    if (this.frame >= images.blast.length) {
                        this.active = false;
                    }
                }
            }
        }

        //Ê∏∏ÊàèBOSSÁ±ª
        class Boss {
            constructor(x, y) {
                this.x = x;//xÔºåy‰∏∫ÂõæÁâá‰∏≠ÂøÉÁÇπÂùêÊ†á
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.life = BOSS_LIFE;
                this.maxLife = BOSS_LIFE;
                this.hitEffect = 0;
                this.center_x = this.x;//Áªü‰∏ÄÂëΩÂêç‰∏≠ÂøÉÔºå‰æø‰∫éÂêéÈù¢ËÆ°ÁÆóÁ¢∞Êíû
                this.center_y = this.y;
            }

            draw() {
                ctx.save();

                // ÁîüÂëΩÂÄº‰Ωé‰∫é‰∏ÄÂçäÊó∂Ë∞ÉÊï¥ÂõæÁâá‰∫ÆÂ∫¶ÂíåÁÅ∞Â∫¶
                if (this.life <= this.maxLife / 2) {
                    ctx.filter = "brightness(60%) grayscale(40%)";
                }

                if (this.hitEffect > 0) {//Â≠êÂºπÂáª‰∏≠ÁâπÊïà
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    this.hitEffect--;
                }

                if (images.boss) {
                    ctx.drawImage(images.boss, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                }

                ctx.restore();
            }

            hit() {
                this.hitEffect = 5;
                this.life--;
            }
        }
        //Âù¶ÂÖãÁ±ª
        class Tank {
            constructor(left, top) {
                this.direction = ["D", "L", "U", "R"][Math.floor(Math.random() * 4)];//ÈöèÊú∫ÊñπÂêë
                this.left = left;
                this.top = top;
                this.speed = ENEMY_TANK_SPEED;
                this.life = ENEMY_TANK_LIFE;
                this.maxLife = ENEMY_TANK_LIFE;
                this.width = 40;
                this.height = 40;
                this.step = Math.floor(Math.random() * 50) + 100;//ÁßªÂä®Ê≠•Èïø
                this.lastShotTime = 0; // ÊïåÊñπÂù¶ÂÖã‰∏äÊ¨°Â∞ÑÂáªÊó∂Èó¥
                this.hitEffect = 0;
                this.updatePosition();//Ê≠§Â§ÑË¶ÅËÆ∞ÂæóÊîæËøô‰∏™ÂáΩÊï∞ÔºåËÆ©left„ÄÅtopÁöÑÂèòÂåñËÉΩÂÆûÊó∂ËÅîÂä®ÂÖ∂‰ªñÂèÇÊï∞
            }

            updatePosition() {
                this.center_x = this.left + this.width / 2;
                this.center_y = this.top + this.height / 2;

                switch (this.direction) {
                    case "R":
                        this.gun_pos_x = this.left + this.width;
                        this.gun_pos_y = this.top + this.height / 2;
                        break;
                    case "L":
                        this.gun_pos_x = this.left;
                        this.gun_pos_y = this.top + this.height / 2;
                        break;
                    case "D":
                        this.gun_pos_x = this.left + this.width / 2;
                        this.gun_pos_y = this.top + this.height;
                        break;
                    case "U":
                        this.gun_pos_x = this.left + this.width / 2;
                        this.gun_pos_y = this.top;
                        break;
                }
            }

            draw() {
                ctx.save();

                // ÁîüÂëΩÂÄº‰Ωé‰∫é‰∏ÄÂçäÊó∂Ë∞ÉÊï¥‰∫ÆÂ∫¶ÂíåÁÅ∞Â∫¶
                if (this.life <= this.maxLife / 2) {
                    ctx.filter = "brightness(60%) grayscale(40%)";
                }

                if (this.hitEffect > 0) {//Âáª‰∏≠ÁâπÊïà
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    this.hitEffect--;
                }

                // Ê†πÊçÆÊñπÂêëÈÄâÊã©Ê≠£Á°ÆÁöÑÂõæÁâá
                let img;
                switch (this.direction) {
                    case "U": img = images.enemyTank.UP; break;
                    case "D": img = images.enemyTank.DOWN; break;
                    case "L": img = images.enemyTank.LEFT; break;
                    case "R": img = images.enemyTank.RIGHT; break;
                }

                if (img) {
                    ctx.drawImage(img, this.left, this.top, this.width, this.height);
                }

                ctx.restore();
            }

            hit() {
                this.hitEffect = 10;//Âù¶ÂÖãË¢´Âáª‰∏≠Êó∂ÁöÑÂÖâÊïàËÆ°Êó∂Âô®
            }

            move() {
                let moved = true;//ÊòØÂê¶ÂèØÁßªÂä®ÁöÑÊ†áËÆ∞
                let newLeft = this.left;
                let newTop = this.top;

                switch (this.direction) {
                    case "L": newLeft -= this.speed; break;
                    case "R": newLeft += this.speed; break;
                    case "U": newTop -= this.speed; break;
                    case "D": newTop += this.speed; break;
                }

                // ËæπÁïåÊ£ÄÊµã
                if (newLeft < 0 || newLeft + this.width > canvas.width ||
                    newTop < 0 || newTop + this.height > canvas.height) {
                    moved = false;
                }

                // ÈöúÁ¢çÁâ©Á¢∞ÊíûÊ£ÄÊµã
                if (moved) {
                    for (let brick of bricks) {
                        if (this.checkCollision(newLeft, newTop, brick)) {
                            moved = false;
                            break;
                        }
                    }
                }

                // BOSSÁ¢∞ÊíûÊ£ÄÊµã
                if (moved && boss && this.checkBossCollision(newLeft, newTop)) {
                    moved = false;
                }

                if (moved) {
                    this.left = newLeft;
                    this.top = newTop;
                    this.updatePosition();
                } else {//Ëã•‰∏çËÉΩÁßªÂä®ÔºåÂàôÈöèÊú∫Êç¢ÊñπÂêëÁßªÂä®
                    this.direction = ["D", "L", "U", "R"][Math.floor(Math.random() * 4)];
                    this.step = Math.floor(Math.random() * 50) + 100;
                }
            }

            checkCollision(x, y, brick) {//ÊòØÂê¶Á¢∞Á†ñÂùóÔºàÊ≤≥ÈÅìÔºâ
                return x < brick.left + brick.width &&
                    x + this.width > brick.left &&
                    y < brick.top + brick.height &&
                    y + this.height > brick.top;
            }

            checkBossCollision(x, y) {//ÊòØÂê¶Á¢∞BOSS
                if (!boss) return false;

                const dx = (x + this.width / 2) - boss.x;
                const dy = (y + this.height / 2) - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.width / 2 + boss.width / 2);
            }

            randomMove() {//ÈöèÊú∫ÁßªÂä®
                const every_step = 1;//Âçï‰ΩçÊ≠•Èïø
                if (this.step <= 0) {//Ê≠•ÈïøÂáèËá≥Èõ∂ÔºåÂàôÈöèÊú∫Êç¢ÊñπÂêë
                    this.direction = ["D", "L", "U", "R"][Math.floor(Math.random() * 4)];
                    this.step = Math.floor(Math.random() * 50) + 100;
                } else {
                    this.move();
                    this.step -= every_step;
                }
            }

            randomShot() {//ÈöèÊú∫Â∞ÑÂáª
                const now = Date.now();
                // ÈôêÂà∂Â∞ÑÂáªÈ¢ëÁéáÔºöÊØè2ÁßíÂè™ËÉΩÂ∞ÑÂáª‰∏ÄÊ¨°
                if (now - this.lastShotTime < 2000) return null;
                const shot_rand = Math.floor(Math.random() * 1000);
                const RANDOM_SHOT_PROBABILITY = 8; // 1/125ÁöÑÊ¶ÇÁéáÂ∞ÑÂáª
                // ÁîüÊàêÈöèÊú∫Êï∞ÔºåËã•Â∞è‰∫éÁ≠â‰∫éËÆæÂÆöÊ¶ÇÁéáÔºåÂàôÂèëÂ∞ÑÂ≠êÂºπ
                if (shot_rand <= RANDOM_SHOT_PROBABILITY) {
                    this.lastShotTime = now;
                    return new Bullet(this);
                }
                return null;
            }
        }

        //ÊàëÊñπÂù¶ÂÖãÁ±ª
        class myTank extends Tank {
            constructor(left, top) {
                super(left, top);
                this.direction = "U";
                this.speed = MYTANK_SPEED;
                this.life = MYTANK_LIFE;
                this.maxLife = MYTANK_LIFE;
                this.lastShotTime = 0;
                this.shotCooldown = 5;//Â∞ÑÂáªCDÊó∂Èó¥5msÔºåÊó†Â§™Â§öÊÑè‰πâÔºå‰∏çÂèØÊåâ‰ΩèÂèëÂ∞ÑÈîÆ‰∏çÂä®
            }

            updateDirection() {
                if (keys.ArrowRight) this.direction = "R";
                else if (keys.ArrowLeft) this.direction = "L";
                else if (keys.ArrowDown) this.direction = "D";
                else if (keys.ArrowUp) this.direction = "U";
            }

            draw() {
                ctx.save();
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';//Âù¶ÂÖãÂ∏¶ÈªÑËâ≤Èò¥ÂΩ±
                ctx.shadowBlur = 15;
                if (this.hitEffect > 0) {
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 25;
                    this.hitEffect--;
                }

                // Ê†πÊçÆÊñπÂêëÈÄâÊã©ÂõæÁâá
                let img;
                switch (this.direction) {
                    case "U": img = images.myTank.UP; break;
                    case "D": img = images.myTank.DOWN; break;
                    case "L": img = images.myTank.LEFT; break;
                    case "R": img = images.myTank.RIGHT; break;
                }

                if (img) {
                    ctx.drawImage(img, this.left, this.top, this.width, this.height);
                }

                ctx.restore();
                //Âù¶ÂÖã‰∏ãÊñπÁöÑÁîüÂëΩÂÄºÊòæÁ§∫
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`ÁîüÂëΩ: ${this.life}`, this.left, this.top - 10);
            }

            move() {
                this.updateDirection();
                let newLeft = this.left;
                let newTop = this.top;

                if (this.direction === "L" && keys.ArrowLeft) {
                    newLeft -= this.speed;
                }
                else if (this.direction === "R" && keys.ArrowRight) {
                    newLeft += this.speed;
                }
                else if (this.direction === "U" && keys.ArrowUp) {
                    newTop -= this.speed;
                }
                else if (this.direction === "D" && keys.ArrowDown) {
                    newTop += this.speed;
                }

                // ËæπÁïåÊ£ÄÊµã
                if (newLeft < 0 || newLeft + this.width > canvas.width ||
                    newTop < 0 || newTop + this.height > canvas.height) {
                    return;
                }

                // ÈöúÁ¢çÁâ©Á¢∞ÊíûÊ£ÄÊµã
                for (let brick of bricks) {
                    if (this.checkCollision(newLeft, newTop, brick)) {
                        return;
                    }
                }

                // BOSSÁ¢∞ÊíûÊ£ÄÊµã
                if (boss && this.checkBossCollision(newLeft, newTop)) {
                    return;
                }

                this.left = newLeft;
                this.top = newTop;
                this.updatePosition();
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShotTime >= this.shotCooldown) {
                    this.lastShotTime = now;
                    return new Bullet(this);
                }
            }
        }
        ////////////////////*****Áõ∏ÂÖ≥ÂáΩÊï∞**********//////////////////////
        //Ê£ÄÊµãÂ≠êÂºπ‰∏éÂçï‰ΩçÁ¢∞ÊíûÂáΩÊï∞ÔºàÂù¶ÂÖãÔºâ
        function checkCollision(bullet, obj) {
            const dx = bullet.x - obj.center_x;
            const dy = bullet.y - obj.center_y;
            const radius = obj.width ? Math.max(obj.width, obj.height) / 2 : 22;
            return Math.sqrt(dx * dx + dy * dy) < radius;
        }

        //Ê£ÄÊµãÂ≠êÂºπ„ÄÅÂ¢ôÁ¢∞ÊíûÂáΩÊï∞
        function checkBulletBrickCollision(bullet, brick) {
            if (brick.type != BRICK_TYPE_RIVER) {
                return bullet.x > brick.left &&
                    bullet.x < brick.left + brick.width &&
                    bullet.y > brick.top &&
                    bullet.y < brick.top + brick.height;
            }
        }

        //ÂéªÊéâÁîüÂëΩÂÄº‰∏∫Èõ∂ÁöÑÂçï‰ΩçÔºàÂ≠êÂºπ„ÄÅÊïåÊñπÂù¶ÂÖã„ÄÅÂ¢ôÔºâÂáΩÊï∞
        function removeDeadObjects(list) {
            for (let i = list.length - 1; i >= 0; i--) {
                if (!list[i].life) {
                    list.splice(i, 1);
                }
            }
        }

        //ÁîüÊàêÊïåÊñπÂù¶ÂÖãÂáΩÊï∞
        function generate_enemytanks(N) {
            let enemyTankList = [];
            for (let i = 0; i < N; i++) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 50) {
                    // ÁîüÊàêÂú®Â±èÂπïÈ°∂ÈÉ®10%È´òÂ∫¶ËåÉÂõ¥ÂÜÖ
                    const x = Math.floor(Math.random() * (canvas.width - 40));
                    const y = Math.floor(Math.random() * (canvas.height * 0.1));
                    const newTank = new Tank(x, y);
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÁ†ñÂùóÈáçÂè†
                    let overlap = false;
                    for (let brick of bricks) {
                        if (newTank.checkCollision(x, y, brick)) {
                            overlap = true;
                            break;
                        }
                    }
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éBOSSÈáçÂè†
                    if (!overlap && boss && newTank.checkBossCollision(x, y)) {
                        overlap = true;
                    }
                    if (!overlap) {
                        enemyTankList.push(newTank);
                        placed = true;
                    }
                    attempts++;
                }
            }
            return enemyTankList;
        }

        // ÁîüÊàêÁ†ñÂùóÔºàÂåÖÊã¨Ê≤≥ÈÅìÔºâ
        function generateBricks() {
            const bricks = [];
            const brickSize = 40;

            // ‰∏≠Èó¥Âõ¥Â¢ôÔºà3x3ÔºåÂë®Âõ¥ÊòØÁ†ñÂ¢ôÔºå‰∏≠Èó¥ÊòØBOSSÔºâ
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const wallSize = brickSize * 3;
            const wallStartX = centerX - wallSize / 2;
            const wallStartY = centerY - wallSize / 2;
            const wallEndY = wallStartY + wallSize;

            // ÂàõÂª∫Âõ¥Â¢ô
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    // Âè™ÂàõÂª∫Âë®Âõ¥ÁöÑÁ†ñÂùóÔºå‰∏≠ÂøÉ‰ΩçÁΩÆÁïôÁ©∫ÁªôBOSS
                    if (i === 1 && j === 1) continue;

                    const x = wallStartX + j * brickSize;
                    const y = wallStartY + i * brickSize;
                    bricks.push(new Brick(x, y, BRICK_TYPE_EARTH));
                }
            }

            // ÂàõÂª∫BOSSÔºàÂú®Âõ¥Â¢ô‰∏≠ÂøÉÔºâ
            boss = new Boss(centerX, centerY);//BOSS‰ΩçÂ±ÖÂ±èÂπïÊ≠£‰∏≠Èó¥

            // ÁîüÊàêÊ≤≥ÈÅì
            const riverMinLength = 6; // 40px *6 Ê≤≥ÈÅìÈïøÂ∫¶
            const riverMaxLength = 10; // 40px*12 Ê≤≥ÈÅìÈïøÂ∫¶
            const minY = canvas.height * 0.15;//Ê≤≥ÈÅì‰ΩçÁΩÆÂå∫Âüü
            const maxY = canvas.height * 0.85 - brickSize;
            const minX = canvas.width * 0.10;
            const maxX = canvas.width * 0.90 - brickSize;

            // Á¨¨‰∏ÄÊù°Ê≤≥ÈÅì
            let river1Y, river1Length, river1XStart;
            let attempts1 = 0;
            do {
                river1Y = Math.floor(Math.random() * (maxY - minY)) + minY;
                attempts1++;
                // Ê£ÄÊü•ÊòØÂê¶‰∏éÂõ¥Â¢ôÈ´òÂ∫¶ÈáçÂè†
            } while (
                river1Y + brickSize > wallStartY && river1Y < wallEndY && attempts1 < 50
            );
            river1Length = Math.floor(Math.random() * (riverMaxLength - riverMinLength + 1)) + riverMinLength;
            river1XStart = Math.floor(Math.random() * (maxX - minX - river1Length * brickSize)) + minX;
            for (let i = 0; i < river1Length; i++) {
                bricks.push(new Brick(river1XStart + i * brickSize, river1Y, BRICK_TYPE_RIVER));
            }

            // Á¨¨‰∫åÊù°Ê≤≥ÈÅìÔºàÁ°Æ‰øù‰∏éÁ¨¨‰∏ÄÊù°Ê≤≥ÈÅì‰∏çÈáçÂè†‰∏îÈÅøÂºÄÂõ¥Â¢ôÔºâ
            let river2Y, river2Length, river2XStart;
            let placed = false;
            let attempts2 = 0;
            while (!placed && attempts2 < 50) {
                river2Y = Math.floor(Math.random() * (maxY - minY)) + minY;
                attempts2++;
                // Ê£ÄÊü•ÊòØÂê¶‰∏éÂõ¥Â¢ôÈ´òÂ∫¶ÈáçÂè†
                if (river2Y + brickSize > wallStartY && river2Y < wallEndY) {
                    continue;
                }
                // Á°Æ‰øù‰∏éÁ¨¨‰∏ÄÊù°Ê≤≥ÈÅì‰øùÊåÅ‰∏ÄÂÆöË∑ùÁ¶ª
                if (Math.abs(river2Y - river1Y) < brickSize * 2) {
                    continue;
                }

                river2Length = Math.floor(Math.random() * (riverMaxLength - riverMinLength + 1)) + riverMinLength;
                river2XStart = Math.floor(Math.random() * (maxX - minX - river2Length * brickSize)) + minX;

                // Ê£ÄÊü•ÊòØÂê¶‰∏éÁ¨¨‰∏ÄÊù°Ê≤≥ÈÅìÈáçÂè†
                let overlap = false;
                for (let i = 0; i < river2Length; i++) {
                    const x = river2XStart + i * brickSize;
                    for (let j = 0; j < river1Length; j++) {
                        const river1X = river1XStart + j * brickSize;
                        if (x === river1X && river2Y === river1Y) {
                            overlap = true;
                            break;
                        }
                    }
                    if (overlap) break;
                }

                if (!overlap) {
                    for (let i = 0; i < river2Length; i++) {
                        bricks.push(new Brick(river2XStart + i * brickSize, river2Y, BRICK_TYPE_RIVER));
                    }
                    placed = true;
                }
            }

            // ÈöèÊú∫Á†ñÂùó (20Âùó)
            const brick_amount = 20;
            for (let i = 0; i < brick_amount; i++) {
                let placed = false;
                let attempts = 0;

                while (!placed && attempts < 50) {//ÊúÄÂ§öÂ∞ùËØïÊîæ50Ê¨°
                    const minX = canvas.width * 0.10;
                    const maxX = canvas.width - minX - brickSize;
                    const minY = canvas.height * 0.15;
                    const maxY = canvas.height - minY - brickSize;

                    const x = Math.floor(Math.random() * (maxX - minX)) + minX;
                    const y = Math.floor(Math.random() * (maxY - minY)) + minY;
                    const type = Math.random() > 0.66 ? BRICK_TYPE_STEEL : BRICK_TYPE_EARTH;//33%Âá†ÁéáÁîüÊàêÈí¢Á†ñ

                    const newBrick = new Brick(x, y, type);

                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÁé∞ÊúâÁ†ñÂùóÈáçÂè†
                    let overlap = false;
                    for (let brick of bricks) {
                        if (newBrick.left < brick.left + brick.width &&
                            newBrick.left + newBrick.width > brick.left &&
                            newBrick.top < brick.top + brick.height &&
                            newBrick.top + newBrick.height > brick.top) {
                            overlap = true;
                            break;
                        }
                    }

                    // Ê£ÄÊü•ÊòØÂê¶‰∏éBOSSÈáçÂè†
                    if (!overlap && boss) {
                        const dx = (x + brickSize / 2) - boss.x;
                        const dy = (y + brickSize / 2) - boss.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < (brickSize / 2 + boss.width / 2)) {
                            overlap = true;
                        }
                    }

                    // Ê£ÄÊü•ÊòØÂê¶Âú®‰∏≠Èó¥Âõ¥Â¢ôÂå∫ÂüüÂÜÖ
                    if (!overlap) {
                        if (x >= wallStartX && x < wallStartX + wallSize &&
                            y >= wallStartY && y < wallStartY + wallSize) {
                            overlap = true;
                        }
                    }

                    if (!overlap) {
                        bricks.push(newBrick);
                        placed = true;
                    }
                    attempts++;
                }
            }

            return bricks;
        }

        //ÈáçÁΩÆÊ∏∏ÊàèÂáΩÊï∞
        function resetGame() {
            enemyTanks.length = 0;
            enemyBullets.length = 0;
            myBullets.length = 0;
            explosions.length = 0;
            bricks.length = 0;

            bricks = generateBricks();
            enemyTanks = generate_enemytanks(ENEMY_TANK_AMOUNT);

            mytank.left = canvas.width / 2;
            mytank.top = canvas.height * 0.90;
            mytank.direction = "U";
            mytank.life = MYTANK_LIFE;
            mytank.updatePosition();

            gameOverlay.style.display = 'none';
            pauseOverlay.style.display = 'none';
            lastFrameTime = performance.now();
            gamePaused = false;
            requestAnimationFrame(gameLoop);

            // Êõ¥Êñ∞Áä∂ÊÄÅÊ†è
            updateStatusBar();
        }

        // Èü≥ÊïàÁîüÊàêÂô®
        function playSound(type) {
            if (!soundEnabled) return;
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Êó†Ê≥ïÂàõÂª∫Èü≥È¢ë‰∏ä‰∏ãÊñá:", e);
                    return;
                }
            }

            // Á°Æ‰øùÈü≥È¢ë‰∏ä‰∏ãÊñáÂ§Ñ‰∫éËøêË°åÁä∂ÊÄÅ
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.log("ÊÅ¢Â§çÈü≥È¢ë‰∏ä‰∏ãÊñáÂ§±Ë¥•:", e));
            }

            let volume = 0.5;
            let oscillator = audioContext.createOscillator();
            let gainNode = audioContext.createGain();
            let now = audioContext.currentTime;
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // ËÆæÁΩÆ‰∏çÂêåÈü≥ÊïàÁöÑÈü≥Ëâ≤
            switch (type) {
                case SOUND_TANK_HIT: // Âù¶ÂÖãË¢´Âáª‰∏≠
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_TANK_EXPLOSION: // Âù¶ÂÖãÁàÜÁÇ∏
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(80, now);
                    oscillator.frequency.exponentialRampToValueAtTime(30, now + 1);
                    gainNode.gain.setValueAtTime(volume * 1.5, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1);
                    oscillator.start(now);
                    oscillator.stop(now + 1);
                    break;

                case SOUND_BRICK_HIT: // Á†ñÂ¢ôË¢´Âáª‰∏≠
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_BRICK_EXPLOSION: // Á†ñÂ¢ôÁàÜÁÇ∏
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_STEEL_HIT: // Èí¢Â¢ôË¢´Âáª‰∏≠
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_STEEL_EXPLOSION: // Èí¢Â¢ôÁàÜÁÇ∏
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.7);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.5);
                    break;

                case SOUND_SHOOT: // Â∞ÑÂáªÈü≥Êïà
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(70, now + 0.2);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    break;
            }
        }

        // Êõ¥Êñ∞Áä∂ÊÄÅÊ†è
        function updateStatusBar() {
            statusBar.textContent = `ÁîüÂëΩ: ${mytank.life} | Êïå‰∫∫: ${enemyTanks.length} | BOSSÁîüÂëΩ: ${boss ? boss.life : 0}`;
        }

        // Ëé∑ÂèñcanvasÁîªÂ∏ÉÂØπË±°
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Ëé∑ÂèñÊ∏∏ÊàèÂÖÉÁ¥†
        const gameOverlay = document.getElementById('gameOverlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const joystickArea = document.getElementById('joystickArea');
        const statusBar = document.getElementById('statusBar');
        const soundToggle = document.getElementById('soundToggle');
        const fireButton = document.getElementById('fireButton');
        const dpadUp = document.getElementById('dpad-up');
        const dpadLeft = document.getElementById('dpad-left');
        const dpadRight = document.getElementById('dpad-right');
        const dpadDown = document.getElementById('dpad-down');

        // ÊåâÈîÆ‰ø°ÊÅØ
        let keys = {
            ArrowUp: false,
            ArrowRight: false,
            ArrowDown: false,
            ArrowLeft: false,
            Space: false
        };

        // ÈîÆÁõò‰∫ã‰ª∂ÁõëÂê¨
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Space'].includes(e.code)) {
                e.preventDefault();
                if (e.code in keys) {
                    keys[e.code] = true;
                    if (keys.Space == true) {
                        let bullet = mytank.shoot();
                        if (bullet) {
                            myBullets.push(bullet);
                            playSound(SOUND_SHOOT);
                        }
                    } else {
                        mytank.updateDirection();
                    }
                }
            }

            // ESCÈîÆÊöÇÂÅú/ÁªßÁª≠Ê∏∏Êàè
            if (e.code === 'Escape') {
                e.preventDefault();
                gamePaused = !gamePaused;
                pauseOverlay.style.display = gamePaused ? 'flex' : 'none';

                // Â¶ÇÊûúÊ∏∏ÊàèÊöÇÂÅúÔºåÂÅúÊ≠¢ÊâÄÊúâÊ∏∏ÊàèÈÄªËæëÔºõÂ¶ÇÊûúÊÅ¢Â§çÔºåÁªßÁª≠Ê∏∏ÊàèÂæ™ÁéØ
                if (!gamePaused) {
                    lastFrameTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Space'].includes(e.code)) {
                e.preventDefault();
                if (e.code in keys) {
                    keys[e.code] = false;
                }
            }
        });

        // ÈáçÂêØÊåâÈíÆ‰∫ã‰ª∂
        restartButton.addEventListener('click', resetGame);

        // Èü≥ÊïàÂºÄÂÖ≥
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.textContent = soundEnabled ? 'üîä' : 'üîá';
        });

        // ÂçÅÂ≠óÈîÆËß¶Êë∏ÊéßÂà∂
        function handleDirectionTouchStart(direction) {
            if (gamePaused) return;
            keys[direction] = true;
            mytank.updateDirection();
        }

        function handleDirectionTouchEnd(direction) {
            keys[direction] = false;
        }

        dpadUp.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadUp.classList.add('active');
            handleDirectionTouchStart('ArrowUp');
        });
        dpadUp.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadUp.classList.remove('active');
            handleDirectionTouchEnd('ArrowUp');
        });

        dpadLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadLeft.classList.add('active');
            handleDirectionTouchStart('ArrowLeft');
        });
        dpadLeft.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadLeft.classList.remove('active');
            handleDirectionTouchEnd('ArrowLeft');
        });

        dpadRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadRight.classList.add('active');
            handleDirectionTouchStart('ArrowRight');
        });
        dpadRight.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadRight.classList.remove('active');
            handleDirectionTouchEnd('ArrowRight');
        });

        dpadDown.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadDown.classList.add('active');
            handleDirectionTouchStart('ArrowDown');
        });
        dpadDown.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadDown.classList.remove('active');
            handleDirectionTouchEnd('ArrowDown');
        });

        // Â∞ÑÂáªÊåâÈíÆËß¶Êë∏ÊéßÂà∂
        fireButton.addEventListener('touchstart', function (e) {
            e.preventDefault();
            if (gamePaused) return;
            keys.Space = true;
            fireButton.classList.add('active');
            let bullet = mytank.shoot();
            if (bullet) {
                myBullets.push(bullet);
                playSound(SOUND_SHOOT);
            }
        });

        fireButton.addEventListener('touchend', function (e) {
            e.preventDefault();
            keys.Space = false;
            fireButton.classList.remove('active');
        });

        fireButton.addEventListener('contextmenu', function (e) {
            e.preventDefault();
        });

        // Ê∏∏ÊàèÂØπË±°
        let bricks = [];
        let enemyTanks = [];
        let enemyBullets = [];
        let myBullets = [];
        let explosions = [];
        let boss = null;
        let mytank = new myTank(canvas.width / 2, canvas.height * 0.90);//Âù¶ÂÖãÂàùÂßã‰ΩçÁΩÆ

        // ÂàùÂßãÂåñÊ∏∏ÊàèÔºàÂú®ÂõæÁâáÂä†ËΩΩÂÆåÊàêÂêéÔºâ
        loadImages().then(() => {
            bricks = generateBricks();
            enemyTanks = generate_enemytanks(ENEMY_TANK_AMOUNT);
            updateStatusBar();
            lastFrameTime = performance.now();
            gameLoop(lastFrameTime);
        });

        // Ê∏∏Êàè‰∏ªÂæ™ÁéØ
        function gameLoop(timestamp) {
            if (gamePaused) return;

            const deltaTime = timestamp - lastFrameTime;
            if (deltaTime < frameInterval) {//ÊéßÂà∂Ê∏∏ÊàèÂ∏ßÁéá
                requestAnimationFrame(gameLoop);
                return;
            }
            lastFrameTime = timestamp - (deltaTime % frameInterval);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ÁªòÂà∂Á†ñÂùó
            for (let brick of bricks) {
                brick.draw();
            }

            // ÁªòÂà∂BOSS
            if (boss) {
                boss.draw();
            }

            // ÊïåÊñπÂù¶ÂÖãÈöèÊú∫Â∞ÑÂáª
            for (let tank of enemyTanks) {
                const bullet = tank.randomShot();
                if (bullet) enemyBullets.push(bullet);
            }

            // Êõ¥Êñ∞ÂíåÁªòÂà∂ÊïåÊñπÂ≠êÂºπ
            for (let j = 0; j < enemyBullets.length; j++) {
                enemyBullets[j].move();
                enemyBullets[j].draw();

                // Ê£ÄÊµãÂ≠êÂºπ‰∏éÊàëÊñπÂù¶ÂÖãÁ¢∞Êíû
                if (checkCollision(enemyBullets[j], mytank)) {
                    enemyBullets[j].life = false;
                    //enemyBullets.splice(j, 1);
                    mytank.life--;
                    mytank.hit();
                    playSound(SOUND_TANK_HIT);
                    if (mytank.life <= 0) {
                        explosions.push(new Explosion(mytank.center_x, mytank.center_y));
                        playSound(SOUND_TANK_EXPLOSION);
                    }
                    updateStatusBar();
                    break;
                }

                // Ê£ÄÊµãÂ≠êÂºπ‰∏éBOSSÁ¢∞Êíû
                if (boss && checkCollision(enemyBullets[j], boss)) {
                    enemyBullets[j].life = false;
                    enemyBullets.splice(j, 1);
                    boss.hit();
                    playSound(SOUND_TANK_HIT);
                    updateStatusBar();
                    break;
                }

                // Ê£ÄÊµãÂ≠êÂºπ‰∏éÁ†ñÂùóÁ¢∞Êíû
                for (let i = bricks.length - 1; i >= 0; i--) {
                    if (checkBulletBrickCollision(enemyBullets[j], bricks[i])) {
                        enemyBullets[j].life = false;
                        enemyBullets.splice(j, 1);
                        bricks[i].hit();

                        if (bricks[i].type === BRICK_TYPE_EARTH) {
                            playSound(SOUND_BRICK_HIT);
                        } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                            playSound(SOUND_STEEL_HIT);
                        }

                        if (bricks[i].life <= 0) {
                            explosions.push(new Explosion(bricks[i].left + bricks[i].width / 2, bricks[i].top + bricks[i].height / 2, true));

                            if (bricks[i].type === BRICK_TYPE_EARTH) {
                                playSound(SOUND_BRICK_EXPLOSION);
                            } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                                playSound(SOUND_STEEL_EXPLOSION);
                            }

                            bricks.splice(i, 1);
                        }
                        break;
                    }
                }
            }

            // Êõ¥Êñ∞ÂíåÁªòÂà∂ÊàëÊñπÂ≠êÂºπ
            for (let j = 0; j < myBullets.length; j++) {
                myBullets[j].move();
                myBullets[j].draw();

                // Ê£ÄÊµãÊàëÊñπÂ≠êÂºπ‰∏éÊïåÊñπÂù¶ÂÖãÁ¢∞Êíû
                for (let i = enemyTanks.length - 1; i >= 0; i--) {
                    if (checkCollision(myBullets[j], enemyTanks[i])) {
                        myBullets[j].life = false;
                        myBullets.splice(j, 1);
                        enemyTanks[i].life--;
                        enemyTanks[i].hit();
                        playSound(SOUND_TANK_HIT);
                        if (enemyTanks[i].life <= 0) {
                            explosions.push(new Explosion(enemyTanks[i].center_x, enemyTanks[i].center_y));
                            enemyTanks.splice(i, 1);
                            playSound(SOUND_TANK_EXPLOSION);
                            updateStatusBar();
                        }
                        break;
                    }
                }

                if (j >= myBullets.length) continue;//Â≠êÂºπÁ¢∞ÊíûÂêéÔºåmyBulletsÂàóË°®Â∑≤Áº©Áü≠

                // Ê£ÄÊµãÊàëÊñπÂ≠êÂºπ‰∏éÁ†ñÂùóÁ¢∞Êíû
                for (let i = bricks.length - 1; i >= 0; i--) {
                    if (checkBulletBrickCollision(myBullets[j], bricks[i])) {
                        myBullets[j].life = false;
                        //myBullets.splice(j, 1);Ê≠§Â§Ñ‰∏çËÉΩÁïôÔºåÂê¶ÂàôÂ≠êÂºπÂáª‰∏≠Â¢ôÂ£ÅÂêéÔºå‰∏ãÈù¢Ê£ÄÊµãÊàëÊñπÂ≠êÂºπ‰∏éBOSSÁ¢∞ÊíûÊó∂‰ºöÊèêÁ§∫ÈîôËØØ„ÄÇ
                        bricks[i].hit();

                        if (bricks[i].type === BRICK_TYPE_EARTH) {
                            playSound(SOUND_BRICK_HIT);
                        } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                            playSound(SOUND_STEEL_HIT);
                        }

                        if (bricks[i].life <= 0) {
                            explosions.push(new Explosion(bricks[i].left + bricks[i].width / 2, bricks[i].top + bricks[i].height / 2, true));

                            if (bricks[i].type === BRICK_TYPE_EARTH) {
                                playSound(SOUND_BRICK_EXPLOSION);
                            } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                                playSound(SOUND_STEEL_EXPLOSION);
                            }

                            bricks.splice(i, 1);
                        }
                        break;
                    }
                }

                // Ê£ÄÊµãÊàëÊñπÂ≠êÂºπ‰∏éBOSSÁ¢∞ÊíûÔºàÊàëÊñπÂ≠êÂºπ‰∏çÊëßÊØÅBOSSÔºå‰ΩÜ‰∏çË∂äËøáBOSSÔºâ
                if (boss && checkCollision(myBullets[j], boss)) {
                    myBullets[j].life = false;
                    myBullets.splice(j, 1);
                    break;
                }
            }

            // Êõ¥Êñ∞ÂíåÁªòÂà∂ÊïåÊñπÂù¶ÂÖã
            for (let tank of enemyTanks) {
                tank.randomMove();
                tank.draw();
            }

            // Êõ¥Êñ∞ÂíåÁªòÂà∂ÊàëÊñπÂù¶ÂÖã
            if (mytank.life > 0) {
                mytank.move();
                mytank.draw();
            }

            // Êõ¥Êñ∞ÂíåÁªòÂà∂ÁàÜÁÇ∏Âä®Áîª
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].draw();
                explosions[i].update();
                if (!explosions[i].active) {
                    explosions.splice(i, 1);
                }
            }

            // ÁßªÈô§Ê≠ª‰∫°ÁöÑÂ≠êÂºπ
            removeDeadObjects(enemyBullets);
            removeDeadObjects(myBullets);

            // Ê∏∏ÊàèÁªìÊùüÊ£ÄÊµã
            if (mytank.life <= 0) {
                messageText.textContent = 'Ê∏∏ÊàèÁªìÊùü';
                messageText.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.8)';
                gameOverlay.style.display = 'flex';
                return;
            }

            // ËÉúÂà©Ê£ÄÊµã
            if (enemyTanks.length == 0) {
                messageText.textContent = 'ËÉúÂà©!';
                messageText.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.8)';
                gameOverlay.style.display = 'flex';
                return;
            }

            // BOSSË¢´Âáª‰∏≠2Ê¨°ÂêéÊ∏∏ÊàèÁªìÊùü
            if (boss && boss.life <= 0) {
                explosions.push(new Explosion(boss.x, boss.y));
                boss = null;
                messageText.textContent = 'BOSSË¢´ÊëßÊØÅ!';
                messageText.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.8)';
                gameOverlay.style.display = 'flex';
                return;
            }

            requestAnimationFrame(gameLoop);
        }
    </script>
</body>

</html>