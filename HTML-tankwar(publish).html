<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <title>å¦å…‹å¯¹æˆ˜æ¸¸æˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            touch-action: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        #canvas {
            display: block;
            background-color: #000;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            display: none;
        }

        #gameMessage {
            text-align: center;
            color: white;
            background: rgba(20, 30, 48, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #4cc9f0;
            box-shadow: 0 0 40px rgba(76, 201, 240, 0.5);
            max-width: 80%;
        }

        #gameMessage h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #fad0c4, #a1c4fd);
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }

        #restartButton {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
            font-weight: bold;
            letter-spacing: 1px;
        }

        #restartButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.8);
        }

        #restartButton:active {
            transform: scale(0.95);
        }

        /* ä¿®æ”¹ï¼šåå­—æ–¹å‘é”®æ ·å¼ */
        #joystickArea {
            position: fixed;
            left: 5vw;
            bottom: 5vw;
            width: 25vw;
            height: 25vw;
            max-width: 30vh;
            max-height: 30vh;
            z-index: 100;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            opacity: 0.7;
        }

        .dpad-button {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.2s;
        }

        .dpad-button.active {
            background: rgba(76, 201, 240, 0.6);
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.8);
        }

        #dpad-up {
            grid-column: 2;
            grid-row: 1;
        }

        #dpad-left {
            grid-column: 1;
            grid-row: 2;
        }

        #dpad-center {
            grid-column: 2;
            grid-row: 2;
            background: transparent;
            border: none;
        }

        #dpad-right {
            grid-column: 3;
            grid-row: 2;
        }

        #dpad-down {
            grid-column: 2;
            grid-row: 3;
        }

        #fireButton {
            position: fixed;
            right: 6vw;
            bottom: 6vw;
            width: 20vw;
            height: 20vw;
            max-width: 25vh;
            max-height: 25vh;
            border-radius: 50%;
            background: rgba(255, 80, 80, 0.2);
            z-index: 100;
            border: 2px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            opacity: 0.7;
        }

        #fireButton.active {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.8);
        }

        #gameTitle {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(77, 211, 248, 0.5);
            font-size: 36px;
            text-shadow: 0 0 15px rgba(76, 201, 240, 0.7);
            z-index: 10;
            font-weight: bold;
            letter-spacing: 2px;
            animation: titleGlow 2s infinite alternate;
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 15px rgba(76, 201, 240, 0.7);
            }

            100% {
                text-shadow: 0 0 25px rgba(76, 201, 240, 1), 0 0 35px rgba(76, 201, 240, 0.8);
            }
        }

        #statusBar {
            position: absolute;
            top: 80px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 10;
            font-size: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            z-index: 15;
            display: none;
        }

        #pauseMessage {
            color: white;
            font-size: 48px;
            text-align: center;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #soundToggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 768px) {
            #instructions {
                font-size: 12px;
                bottom: 100px;
                padding: 6px 12px;
            }

            #gameTitle {
                font-size: 28px;
                top: 15px;
            }

            #statusBar {
                top: 65px;
                font-size: 14px;
                padding: 6px 12px;
            }
        }
    </style>
</head>

<body>
    <div id="gameTitle">ğŸš© å¦å…‹å¤§æˆ˜ ğŸš©</div>
    <canvas id="canvas"></canvas>
    <div id="instructions">
        æ–¹å‘é”®ç§»åŠ¨ | ç©ºæ ¼é”®å°„å‡» | ESCæš‚åœ
    </div>
    <div id="statusBar">ç”Ÿå‘½: 5 | æ•Œäºº: 10 | BOSSç”Ÿå‘½: 2</div>

    <div id="gameOverlay">
        <div id="gameMessage">
            <h1 id="messageText">æ¸¸æˆç»“æŸ</h1>
            <button id="restartButton">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <div id="pauseOverlay">
        <div id="pauseMessage">æ¸¸æˆæš‚åœ<br><small>æŒ‰ESCç»§ç»­</small></div>
    </div>

    <!-- ä¿®æ”¹ï¼šåå­—æ–¹å‘é”® -->
    <div id="joystickArea">
        <div id="dpad-up" class="dpad-button">â†‘</div>
        <div id="dpad-left" class="dpad-button">â†</div>
        <div id="dpad-center" class="dpad-button"></div>
        <div id="dpad-right" class="dpad-button">â†’</div>
        <div id="dpad-down" class="dpad-button">â†“</div>
    </div>
    <div id="fireButton"></div>
    <div id="soundToggle">ğŸ”Š</div>

    <script>
        // å¸§ç‡æ§åˆ¶ (80Hz)
        const targetFPS = 80;
        const frameInterval = 1000 / targetFPS;
        let lastFrameTime = 0;
        let gamePaused = false;

        // æ¸¸æˆåŸºæœ¬å‚æ•°å¸¸é‡
        const ENEMY_TANK_LIFE = 2;
        const ENEMY_TANK_SPEED = 3;
        const ENEMY_TANK_AMOUNT = 10;
        const ENEMY_TANK_BULLET_SPEED = 6;
        const MYTANK_BULLET_SPEED = 8;
        const MYTANK_SPEED = 4;
        const MYTANK_LIFE = 5;
        const BOSS_LIFE = 2;
        const BRICK_LIFE = 3;
        const STEEL_LIFE = 9;
        const RIVER_LIFE = 999; // æ²³é“ä¸å¯æ‘§æ¯

        //é…è‰²å¸¸é‡
        const myBullet_color = "yellow";
        const enemyBullets_color = "red";

        // ç –å—ç±»å‹å¸¸é‡
        const BRICK_TYPE_STEEL = 1; // é’¢ç –ç±»å‹
        const BRICK_TYPE_EARTH = 2; // åœŸç –ç±»å‹
        const BRICK_TYPE_RIVER = 3; // æ²³é“ç±»å‹

        // éŸ³æ•ˆå¸¸é‡
        const SOUND_TANK_HIT = 0;
        const SOUND_TANK_EXPLOSION = 1;
        const SOUND_BRICK_HIT = 2;
        const SOUND_BRICK_EXPLOSION = 3;
        const SOUND_STEEL_HIT = 4;
        const SOUND_STEEL_EXPLOSION = 5;
        const SOUND_SHOOT = 6;

        // éŸ³æ•ˆçŠ¶æ€
        let soundEnabled = true;
        let audioContext = null;
        let brickExplosionGif = null;

        // å›¾ç‰‡å¯¹è±¡
        const images = {
            enemyTank: {
                UP: null,
                DOWN: null,
                LEFT: null,
                RIGHT: null
            },
            myTank: {
                UP: null,
                DOWN: null,
                LEFT: null,
                RIGHT: null
            },
            bricks: null,
            steels: null,
            river: null, // æ²³é“å›¾ç‰‡
            boss: null,
            blast: []
        };

        //å›¾ç‰‡ç½‘å€èµ„æº
        const url_enemyTank1_UP = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_UP.png';
        const url_enemyTank1_DOWN = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_DOWN.png';
        const url_enemyTank1_LEFT = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_LEFT.png';
        const url_enemyTank1_RIGHT = 'https://uy.wzznft.com/i/2025/08/10/enemyTank1_RIGHT.png';
        const url_myTank_UP = 'https://uy.wzznft.com/i/2025/08/10/mytank2_UP.png';
        const url_myTank_DOWN = 'https://uy.wzznft.com/i/2025/08/10/mytank2_DOWN.png';
        const url_myTank_LEFT = 'https://uy.wzznft.com/i/2025/08/10/mytank2_LEFT.png';
        const url_myTank_RIGHT = 'https://uy.wzznft.com/i/2025/08/10/mytank2_RIGHT.png';
        const url_bricks = 'https://uy.wzznft.com/i/2025/08/10/bricks.png';
        const url_steels = 'https://uy.wzznft.com/i/2025/08/10/steels.png';
        const url_river = 'https://uy.wzznft.com/i/2025/08/11/river.png';
        const url_boss = 'https://uy.wzznft.com/i/2025/08/10/boss.png';
        const url_brickExplosionGif = 'https://uy.wzznft.com/i/2025/08/13/brick_explosion_1.gif';

        //loadImage(url_brickExplosionGif).then(img => brickExplosionGif = img);
        // é¢„åŠ è½½å›¾ç‰‡
        function loadImages() {
            const promises = [];

            // æ•Œæ–¹å¦å…‹å›¾ç‰‡
            promises.push(loadImage(url_enemyTank1_UP).then(img => images.enemyTank.UP = img));
            promises.push(loadImage(url_enemyTank1_DOWN).then(img => images.enemyTank.DOWN = img));
            promises.push(loadImage(url_enemyTank1_LEFT).then(img => images.enemyTank.LEFT = img));
            promises.push(loadImage(url_enemyTank1_RIGHT).then(img => images.enemyTank.RIGHT = img));

            // æˆ‘æ–¹å¦å…‹å›¾ç‰‡
            promises.push(loadImage(url_myTank_UP).then(img => images.myTank.UP = img));
            promises.push(loadImage(url_myTank_DOWN).then(img => images.myTank.DOWN = img));
            promises.push(loadImage(url_myTank_LEFT).then(img => images.myTank.LEFT = img));
            promises.push(loadImage(url_myTank_RIGHT).then(img => images.myTank.RIGHT = img));

            // ç –å¢™é’¢å¢™å›¾ç‰‡
            promises.push(loadImage(url_bricks).then(img => images.bricks = img));
            promises.push(loadImage(url_steels).then(img => images.steels = img));

            // æ²³é“å›¾ç‰‡
            promises.push(loadImage(url_river).then(img => images.river = img));

            // BOSSå›¾ç‰‡
            promises.push(loadImage(url_boss).then(img => images.boss = img));

            // ç –å—çˆ†ç‚¸GIF
            promises.push(loadImage(url_brickExplosionGif).then(img => brickExplosionGif = img));

            // çˆ†ç‚¸åŠ¨ç”»å›¾ç‰‡
            for (let i = -1; i < 4; i++) {//å…±5å¸§ï¼Œåç§°åç¼€ä»-1~3
                promises.push(loadImage(`https://uy.wzznft.com/i/2025/08/10/blast${i}.png`).then(img => {
                    images.blast.push(img);
                }));
            }

            return Promise.all(promises);
        }
        //è½½å…¥ç½‘å€å›¾ç‰‡
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        // ç –å—ç±»å®šä¹‰ï¼ˆå«æ²³é“ï¼‰
        class Brick {
            constructor(left, top, type) {
                this.left = left;
                this.top = top;
                this.width = 40;
                this.height = 40;
                this.type = type;//å¢™ä½“ç±»å‹
                this.life = type == BRICK_TYPE_STEEL ? STEEL_LIFE :
                    type == BRICK_TYPE_RIVER ? RIVER_LIFE : BRICK_LIFE;
                this.hitEffect = 0;//è¢«å‡»ä¸­æ—¶çš„è§†è§‰æ•ˆæœå¸§æ•°
            }

            draw() {// å‡»ä¸­æ•ˆæœ                
                if (this.type != BRICK_TYPE_RIVER) {//éæ²³é“
                    if (this.hitEffect > 0) {
                        ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';//è¢«å‡»ä¸­åçš„çº¢è‰²é—ªå…‰
                        ctx.shadowBlur = 20;//é—ªå…‰é˜´å½±çš„å¤§å°
                        this.hitEffect--;//ç‰¹æ•ˆå¸§æ•°
                    }
                }

                // ç»˜åˆ¶ç –å—å›¾ç‰‡
                let img;
                if (this.type === BRICK_TYPE_STEEL) {
                    img = images.steels;
                } else if (this.type === BRICK_TYPE_RIVER) {
                    img = images.river;
                } else {
                    img = images.bricks;
                }
                if (img) {
                    ctx.drawImage(img, this.left, this.top, this.width, this.height);
                }

                ctx.shadowBlur = 0;
            }

            hit() {
                if (this.type == BRICK_TYPE_RIVER) return; // å¿½ç•¥æ²³é“ä¸å­å¼¹ç¢°æ’
                this.hitEffect = 5;
                this.life--;
            }
        }
        //å­å¼¹ç±»
        class Bullet {
            constructor(tank) {
                this.x = tank.gun_pos_x;//å¦å…‹ç‚®å£ä½ç½®
                this.y = tank.gun_pos_y;
                this.direction = tank.direction;
                this.speed = tank instanceof myTank ? MYTANK_BULLET_SPEED : ENEMY_TANK_BULLET_SPEED;
                this.life = true;
                this.radius = 4;
                this.color = tank instanceof myTank ? myBullet_color : enemyBullets_color;
            }

            draw() {
                if (!this.life) return;

                // ç»˜åˆ¶å­å¼¹
                ctx.beginPath();
                ctx.fillStyle = this.color;
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            move() {
                if (!this.life) return;
                switch (this.direction) {
                    case "L": this.x -= this.speed; break;
                    case "R": this.x += this.speed; break;
                    case "U": this.y -= this.speed; break;
                    case "D": this.y += this.speed; break;
                }
                if (this.x < 0 || this.x > canvas.width ||
                    this.y < 0 || this.y > canvas.height) {
                    this.life = false;
                }
            }
        }
        //çˆ†ç‚¸äº‹ä»¶ç±»ï¼ˆåŠ¨ç”»ï¼‰
        class Explosion {
            constructor(x, y, isBrick = false) {
                this.x = x;
                this.y = y;
                this.frame = 0;
                this.lastFrameTime = Date.now();
                this.frameDelay = 100;
                this.width = 70;
                this.height = 70;
                this.active = true;
                this.isBrick = isBrick;
                this.gifImg = null;
                this.gifTimeout = null;
            }

            draw() {
                if (!this.active) return;
                if (this.isBrick && brickExplosionGif) {
                    if (!this.gifImg) {
                        // åˆ›å»ºGIFå›¾ç‰‡å¹¶å®šä½åˆ°çˆ†ç‚¸ä½ç½®
                        this.gifImg = document.createElement('img');
                        this.gifImg.src = brickExplosionGif.src;
                        this.gifImg.style.position = 'absolute';
                        this.gifImg.style.left = (this.x - this.width / 2) + 'px';
                        this.gifImg.style.top = (this.y - this.height / 2) + 'px';
                        this.gifImg.style.width = this.width + 'px';
                        this.gifImg.style.height = this.height + 'px';
                        this.gifImg.style.pointerEvents = 'none';
                        this.gifImg.style.zIndex = 999;
                        document.body.appendChild(this.gifImg);

                        // åŠ¨ç”»ç»“æŸåç§»é™¤GIFå›¾ç‰‡
                        this.gifTimeout = setTimeout(() => {
                            if (this.gifImg) {
                                document.body.removeChild(this.gifImg);
                                this.gifImg = null;
                            }
                            this.active = false;
                        }, 1000); // GIFåŠ¨ç”»æ—¶é•¿ï¼ˆå»ºè®®å’ŒGIFé•¿åº¦ä¸€è‡´ï¼‰
                    }
                } else {
                    // åŸæœ‰çˆ†ç‚¸å¸§åŠ¨ç”»
                    const img = images.blast[this.frame];
                    if (img) {
                        ctx.drawImage(img, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    }
                }
            }

            update() {
                if (!this.active) return;
                if (this.isBrick && brickExplosionGif) return; // GIFåŠ¨ç”»ä¸éœ€è¦é€å¸§
                const now = Date.now();
                if (now - this.lastFrameTime > this.frameDelay) {
                    this.frame++;
                    this.lastFrameTime = now;
                    if (this.frame >= images.blast.length) {
                        this.active = false;
                    }
                }
            }
        }

        //æ¸¸æˆBOSSç±»
        class Boss {
            constructor(x, y) {
                this.x = x;//xï¼Œyä¸ºå›¾ç‰‡ä¸­å¿ƒç‚¹åæ ‡
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.life = BOSS_LIFE;
                this.maxLife = BOSS_LIFE;
                this.hitEffect = 0;
                this.center_x = this.x;//ç»Ÿä¸€å‘½åä¸­å¿ƒï¼Œä¾¿äºåé¢è®¡ç®—ç¢°æ’
                this.center_y = this.y;
            }

            draw() {
                ctx.save();

                // ç”Ÿå‘½å€¼ä½äºä¸€åŠæ—¶è°ƒæ•´å›¾ç‰‡äº®åº¦å’Œç°åº¦
                if (this.life <= this.maxLife / 2) {
                    ctx.filter = "brightness(60%) grayscale(40%)";
                }

                if (this.hitEffect > 0) {//å­å¼¹å‡»ä¸­ç‰¹æ•ˆ
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    this.hitEffect--;
                }

                if (images.boss) {
                    ctx.drawImage(images.boss, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                }

                ctx.restore();
            }

            hit() {
                this.hitEffect = 5;
                this.life--;
            }
        }
        //å¦å…‹ç±»
        class Tank {
            constructor(left, top) {
                this.direction = ["D", "L", "U", "R"][Math.floor(Math.random() * 4)];//éšæœºæ–¹å‘
                this.left = left;
                this.top = top;
                this.speed = ENEMY_TANK_SPEED;
                this.life = ENEMY_TANK_LIFE;
                this.maxLife = ENEMY_TANK_LIFE;
                this.width = 40;
                this.height = 40;
                this.step = Math.floor(Math.random() * 50) + 100;//ç§»åŠ¨æ­¥é•¿
                this.lastShotTime = 0; // æ•Œæ–¹å¦å…‹ä¸Šæ¬¡å°„å‡»æ—¶é—´
                this.hitEffect = 0;
                this.updatePosition();//æ­¤å¤„è¦è®°å¾—æ”¾è¿™ä¸ªå‡½æ•°ï¼Œè®©leftã€topçš„å˜åŒ–èƒ½å®æ—¶è”åŠ¨å…¶ä»–å‚æ•°
            }

            updatePosition() {
                this.center_x = this.left + this.width / 2;
                this.center_y = this.top + this.height / 2;

                switch (this.direction) {
                    case "R":
                        this.gun_pos_x = this.left + this.width;
                        this.gun_pos_y = this.top + this.height / 2;
                        break;
                    case "L":
                        this.gun_pos_x = this.left;
                        this.gun_pos_y = this.top + this.height / 2;
                        break;
                    case "D":
                        this.gun_pos_x = this.left + this.width / 2;
                        this.gun_pos_y = this.top + this.height;
                        break;
                    case "U":
                        this.gun_pos_x = this.left + this.width / 2;
                        this.gun_pos_y = this.top;
                        break;
                }
            }

            draw() {
                ctx.save();

                // ç”Ÿå‘½å€¼ä½äºä¸€åŠæ—¶è°ƒæ•´äº®åº¦å’Œç°åº¦
                if (this.life <= this.maxLife / 2) {
                    ctx.filter = "brightness(60%) grayscale(40%)";
                }

                if (this.hitEffect > 0) {//å‡»ä¸­ç‰¹æ•ˆ
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 20;
                    this.hitEffect--;
                }

                // æ ¹æ®æ–¹å‘é€‰æ‹©æ­£ç¡®çš„å›¾ç‰‡
                let img;
                switch (this.direction) {
                    case "U": img = images.enemyTank.UP; break;
                    case "D": img = images.enemyTank.DOWN; break;
                    case "L": img = images.enemyTank.LEFT; break;
                    case "R": img = images.enemyTank.RIGHT; break;
                }

                if (img) {
                    ctx.drawImage(img, this.left, this.top, this.width, this.height);
                }

                ctx.restore();
            }

            hit() {
                this.hitEffect = 10;//å¦å…‹è¢«å‡»ä¸­æ—¶çš„å…‰æ•ˆè®¡æ—¶å™¨
            }

            move() {
                let moved = true;//æ˜¯å¦å¯ç§»åŠ¨çš„æ ‡è®°
                let newLeft = this.left;
                let newTop = this.top;

                switch (this.direction) {
                    case "L": newLeft -= this.speed; break;
                    case "R": newLeft += this.speed; break;
                    case "U": newTop -= this.speed; break;
                    case "D": newTop += this.speed; break;
                }

                // è¾¹ç•Œæ£€æµ‹
                if (newLeft < 0 || newLeft + this.width > canvas.width ||
                    newTop < 0 || newTop + this.height > canvas.height) {
                    moved = false;
                }

                // éšœç¢ç‰©ç¢°æ’æ£€æµ‹
                if (moved) {
                    for (let brick of bricks) {
                        if (this.checkCollision(newLeft, newTop, brick)) {
                            moved = false;
                            break;
                        }
                    }
                }

                // BOSSç¢°æ’æ£€æµ‹
                if (moved && boss && this.checkBossCollision(newLeft, newTop)) {
                    moved = false;
                }

                if (moved) {
                    this.left = newLeft;
                    this.top = newTop;
                    this.updatePosition();
                } else {//è‹¥ä¸èƒ½ç§»åŠ¨ï¼Œåˆ™éšæœºæ¢æ–¹å‘ç§»åŠ¨
                    this.direction = ["D", "L", "U", "R"][Math.floor(Math.random() * 4)];
                    this.step = Math.floor(Math.random() * 50) + 100;
                }
            }

            checkCollision(x, y, brick) {//æ˜¯å¦ç¢°ç –å—ï¼ˆæ²³é“ï¼‰
                return x < brick.left + brick.width &&
                    x + this.width > brick.left &&
                    y < brick.top + brick.height &&
                    y + this.height > brick.top;
            }

            checkBossCollision(x, y) {//æ˜¯å¦ç¢°BOSS
                if (!boss) return false;

                const dx = (x + this.width / 2) - boss.x;
                const dy = (y + this.height / 2) - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.width / 2 + boss.width / 2);
            }

            randomMove() {//éšæœºç§»åŠ¨
                const every_step = 1;//å•ä½æ­¥é•¿
                if (this.step <= 0) {//æ­¥é•¿å‡è‡³é›¶ï¼Œåˆ™éšæœºæ¢æ–¹å‘
                    this.direction = ["D", "L", "U", "R"][Math.floor(Math.random() * 4)];
                    this.step = Math.floor(Math.random() * 50) + 100;
                } else {
                    this.move();
                    this.step -= every_step;
                }
            }

            randomShot() {//éšæœºå°„å‡»
                const now = Date.now();
                // é™åˆ¶å°„å‡»é¢‘ç‡ï¼šæ¯2ç§’åªèƒ½å°„å‡»ä¸€æ¬¡
                if (now - this.lastShotTime < 2000) return null;
                const shot_rand = Math.floor(Math.random() * 1000);
                const RANDOM_SHOT_PROBABILITY = 8; // 1/125çš„æ¦‚ç‡å°„å‡»
                // ç”Ÿæˆéšæœºæ•°ï¼Œè‹¥å°äºç­‰äºè®¾å®šæ¦‚ç‡ï¼Œåˆ™å‘å°„å­å¼¹
                if (shot_rand <= RANDOM_SHOT_PROBABILITY) {
                    this.lastShotTime = now;
                    return new Bullet(this);
                }
                return null;
            }
        }

        //æˆ‘æ–¹å¦å…‹ç±»
        class myTank extends Tank {
            constructor(left, top) {
                super(left, top);
                this.direction = "U";
                this.speed = MYTANK_SPEED;
                this.life = MYTANK_LIFE;
                this.maxLife = MYTANK_LIFE;
                this.lastShotTime = 0;
                this.shotCooldown = 5;//å°„å‡»CDæ—¶é—´5msï¼Œæ— å¤ªå¤šæ„ä¹‰ï¼Œä¸å¯æŒ‰ä½å‘å°„é”®ä¸åŠ¨
            }

            updateDirection() {
                if (keys.ArrowRight) this.direction = "R";
                else if (keys.ArrowLeft) this.direction = "L";
                else if (keys.ArrowDown) this.direction = "D";
                else if (keys.ArrowUp) this.direction = "U";
            }

            draw() {
                ctx.save();
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';//å¦å…‹å¸¦é»„è‰²é˜´å½±
                ctx.shadowBlur = 15;
                if (this.hitEffect > 0) {
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 25;
                    this.hitEffect--;
                }

                // æ ¹æ®æ–¹å‘é€‰æ‹©å›¾ç‰‡
                let img;
                switch (this.direction) {
                    case "U": img = images.myTank.UP; break;
                    case "D": img = images.myTank.DOWN; break;
                    case "L": img = images.myTank.LEFT; break;
                    case "R": img = images.myTank.RIGHT; break;
                }

                if (img) {
                    ctx.drawImage(img, this.left, this.top, this.width, this.height);
                }

                ctx.restore();
                //å¦å…‹ä¸‹æ–¹çš„ç”Ÿå‘½å€¼æ˜¾ç¤º
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`ç”Ÿå‘½: ${this.life}`, this.left, this.top - 10);
            }

            move() {
                this.updateDirection();
                let newLeft = this.left;
                let newTop = this.top;

                if (this.direction === "L" && keys.ArrowLeft) {
                    newLeft -= this.speed;
                }
                else if (this.direction === "R" && keys.ArrowRight) {
                    newLeft += this.speed;
                }
                else if (this.direction === "U" && keys.ArrowUp) {
                    newTop -= this.speed;
                }
                else if (this.direction === "D" && keys.ArrowDown) {
                    newTop += this.speed;
                }

                // è¾¹ç•Œæ£€æµ‹
                if (newLeft < 0 || newLeft + this.width > canvas.width ||
                    newTop < 0 || newTop + this.height > canvas.height) {
                    return;
                }

                // éšœç¢ç‰©ç¢°æ’æ£€æµ‹
                for (let brick of bricks) {
                    if (this.checkCollision(newLeft, newTop, brick)) {
                        return;
                    }
                }

                // BOSSç¢°æ’æ£€æµ‹
                if (boss && this.checkBossCollision(newLeft, newTop)) {
                    return;
                }

                this.left = newLeft;
                this.top = newTop;
                this.updatePosition();
            }

            shoot() {
                const now = Date.now();
                if (now - this.lastShotTime >= this.shotCooldown) {
                    this.lastShotTime = now;
                    return new Bullet(this);
                }
            }
        }
        ////////////////////*****ç›¸å…³å‡½æ•°**********//////////////////////
        //æ£€æµ‹å­å¼¹ä¸å•ä½ç¢°æ’å‡½æ•°ï¼ˆå¦å…‹ï¼‰
        function checkCollision(bullet, obj) {
            const dx = bullet.x - obj.center_x;
            const dy = bullet.y - obj.center_y;
            const radius = obj.width ? Math.max(obj.width, obj.height) / 2 : 22;
            return Math.sqrt(dx * dx + dy * dy) < radius;
        }

        //æ£€æµ‹å­å¼¹ã€å¢™ç¢°æ’å‡½æ•°
        function checkBulletBrickCollision(bullet, brick) {
            if (brick.type != BRICK_TYPE_RIVER) {
                return bullet.x > brick.left &&
                    bullet.x < brick.left + brick.width &&
                    bullet.y > brick.top &&
                    bullet.y < brick.top + brick.height;
            }
        }

        //å»æ‰ç”Ÿå‘½å€¼ä¸ºé›¶çš„å•ä½ï¼ˆå­å¼¹ã€æ•Œæ–¹å¦å…‹ã€å¢™ï¼‰å‡½æ•°
        function removeDeadObjects(list) {
            for (let i = list.length - 1; i >= 0; i--) {
                if (!list[i].life) {
                    list.splice(i, 1);
                }
            }
        }

        //ç”Ÿæˆæ•Œæ–¹å¦å…‹å‡½æ•°
        function generate_enemytanks(N) {
            let enemyTankList = [];
            for (let i = 0; i < N; i++) {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 50) {
                    // ç”Ÿæˆåœ¨å±å¹•é¡¶éƒ¨10%é«˜åº¦èŒƒå›´å†…
                    const x = Math.floor(Math.random() * (canvas.width - 40));
                    const y = Math.floor(Math.random() * (canvas.height * 0.1));
                    const newTank = new Tank(x, y);
                    // æ£€æŸ¥æ˜¯å¦ä¸ç –å—é‡å 
                    let overlap = false;
                    for (let brick of bricks) {
                        if (newTank.checkCollision(x, y, brick)) {
                            overlap = true;
                            break;
                        }
                    }
                    // æ£€æŸ¥æ˜¯å¦ä¸BOSSé‡å 
                    if (!overlap && boss && newTank.checkBossCollision(x, y)) {
                        overlap = true;
                    }
                    if (!overlap) {
                        enemyTankList.push(newTank);
                        placed = true;
                    }
                    attempts++;
                }
            }
            return enemyTankList;
        }

        // ç”Ÿæˆç –å—ï¼ˆåŒ…æ‹¬æ²³é“ï¼‰
        function generateBricks() {
            const bricks = [];
            const brickSize = 40;

            // ä¸­é—´å›´å¢™ï¼ˆ3x3ï¼Œå‘¨å›´æ˜¯ç –å¢™ï¼Œä¸­é—´æ˜¯BOSSï¼‰
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const wallSize = brickSize * 3;
            const wallStartX = centerX - wallSize / 2;
            const wallStartY = centerY - wallSize / 2;
            const wallEndY = wallStartY + wallSize;

            // åˆ›å»ºå›´å¢™
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    // åªåˆ›å»ºå‘¨å›´çš„ç –å—ï¼Œä¸­å¿ƒä½ç½®ç•™ç©ºç»™BOSS
                    if (i === 1 && j === 1) continue;

                    const x = wallStartX + j * brickSize;
                    const y = wallStartY + i * brickSize;
                    bricks.push(new Brick(x, y, BRICK_TYPE_EARTH));
                }
            }

            // åˆ›å»ºBOSSï¼ˆåœ¨å›´å¢™ä¸­å¿ƒï¼‰
            boss = new Boss(centerX, centerY);//BOSSä½å±…å±å¹•æ­£ä¸­é—´

            // ç”Ÿæˆæ²³é“
            const riverMinLength = 6; // 40px *6 æ²³é“é•¿åº¦
            const riverMaxLength = 10; // 40px*12 æ²³é“é•¿åº¦
            const minY = canvas.height * 0.15;//æ²³é“ä½ç½®åŒºåŸŸ
            const maxY = canvas.height * 0.85 - brickSize;
            const minX = canvas.width * 0.10;
            const maxX = canvas.width * 0.90 - brickSize;

            // ç¬¬ä¸€æ¡æ²³é“
            let river1Y, river1Length, river1XStart;
            let attempts1 = 0;
            do {
                river1Y = Math.floor(Math.random() * (maxY - minY)) + minY;
                attempts1++;
                // æ£€æŸ¥æ˜¯å¦ä¸å›´å¢™é«˜åº¦é‡å 
            } while (
                river1Y + brickSize > wallStartY && river1Y < wallEndY && attempts1 < 50
            );
            river1Length = Math.floor(Math.random() * (riverMaxLength - riverMinLength + 1)) + riverMinLength;
            river1XStart = Math.floor(Math.random() * (maxX - minX - river1Length * brickSize)) + minX;
            for (let i = 0; i < river1Length; i++) {
                bricks.push(new Brick(river1XStart + i * brickSize, river1Y, BRICK_TYPE_RIVER));
            }

            // ç¬¬äºŒæ¡æ²³é“ï¼ˆç¡®ä¿ä¸ç¬¬ä¸€æ¡æ²³é“ä¸é‡å ä¸”é¿å¼€å›´å¢™ï¼‰
            let river2Y, river2Length, river2XStart;
            let placed = false;
            let attempts2 = 0;
            while (!placed && attempts2 < 50) {
                river2Y = Math.floor(Math.random() * (maxY - minY)) + minY;
                attempts2++;
                // æ£€æŸ¥æ˜¯å¦ä¸å›´å¢™é«˜åº¦é‡å 
                if (river2Y + brickSize > wallStartY && river2Y < wallEndY) {
                    continue;
                }
                // ç¡®ä¿ä¸ç¬¬ä¸€æ¡æ²³é“ä¿æŒä¸€å®šè·ç¦»
                if (Math.abs(river2Y - river1Y) < brickSize * 2) {
                    continue;
                }

                river2Length = Math.floor(Math.random() * (riverMaxLength - riverMinLength + 1)) + riverMinLength;
                river2XStart = Math.floor(Math.random() * (maxX - minX - river2Length * brickSize)) + minX;

                // æ£€æŸ¥æ˜¯å¦ä¸ç¬¬ä¸€æ¡æ²³é“é‡å 
                let overlap = false;
                for (let i = 0; i < river2Length; i++) {
                    const x = river2XStart + i * brickSize;
                    for (let j = 0; j < river1Length; j++) {
                        const river1X = river1XStart + j * brickSize;
                        if (x === river1X && river2Y === river1Y) {
                            overlap = true;
                            break;
                        }
                    }
                    if (overlap) break;
                }

                if (!overlap) {
                    for (let i = 0; i < river2Length; i++) {
                        bricks.push(new Brick(river2XStart + i * brickSize, river2Y, BRICK_TYPE_RIVER));
                    }
                    placed = true;
                }
            }

            // éšæœºç –å— (20å—)
            const brick_amount = 20;
            for (let i = 0; i < brick_amount; i++) {
                let placed = false;
                let attempts = 0;

                while (!placed && attempts < 50) {//æœ€å¤šå°è¯•æ”¾50æ¬¡
                    const minX = canvas.width * 0.10;
                    const maxX = canvas.width - minX - brickSize;
                    const minY = canvas.height * 0.15;
                    const maxY = canvas.height - minY - brickSize;

                    const x = Math.floor(Math.random() * (maxX - minX)) + minX;
                    const y = Math.floor(Math.random() * (maxY - minY)) + minY;
                    const type = Math.random() > 0.66 ? BRICK_TYPE_STEEL : BRICK_TYPE_EARTH;//33%å‡ ç‡ç”Ÿæˆé’¢ç –

                    const newBrick = new Brick(x, y, type);

                    // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰ç –å—é‡å 
                    let overlap = false;
                    for (let brick of bricks) {
                        if (newBrick.left < brick.left + brick.width &&
                            newBrick.left + newBrick.width > brick.left &&
                            newBrick.top < brick.top + brick.height &&
                            newBrick.top + newBrick.height > brick.top) {
                            overlap = true;
                            break;
                        }
                    }

                    // æ£€æŸ¥æ˜¯å¦ä¸BOSSé‡å 
                    if (!overlap && boss) {
                        const dx = (x + brickSize / 2) - boss.x;
                        const dy = (y + brickSize / 2) - boss.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < (brickSize / 2 + boss.width / 2)) {
                            overlap = true;
                        }
                    }

                    // æ£€æŸ¥æ˜¯å¦åœ¨ä¸­é—´å›´å¢™åŒºåŸŸå†…
                    if (!overlap) {
                        if (x >= wallStartX && x < wallStartX + wallSize &&
                            y >= wallStartY && y < wallStartY + wallSize) {
                            overlap = true;
                        }
                    }

                    if (!overlap) {
                        bricks.push(newBrick);
                        placed = true;
                    }
                    attempts++;
                }
            }

            return bricks;
        }

        //é‡ç½®æ¸¸æˆå‡½æ•°
        function resetGame() {
            enemyTanks.length = 0;
            enemyBullets.length = 0;
            myBullets.length = 0;
            explosions.length = 0;
            bricks.length = 0;

            bricks = generateBricks();
            enemyTanks = generate_enemytanks(ENEMY_TANK_AMOUNT);

            mytank.left = canvas.width / 2;
            mytank.top = canvas.height * 0.90;
            mytank.direction = "U";
            mytank.life = MYTANK_LIFE;
            mytank.updatePosition();

            gameOverlay.style.display = 'none';
            pauseOverlay.style.display = 'none';
            lastFrameTime = performance.now();
            gamePaused = false;
            requestAnimationFrame(gameLoop);

            // æ›´æ–°çŠ¶æ€æ 
            updateStatusBar();
        }

        // éŸ³æ•ˆç”Ÿæˆå™¨
        function playSound(type) {
            if (!soundEnabled) return;
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("æ— æ³•åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡:", e);
                    return;
                }
            }

            // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºè¿è¡ŒçŠ¶æ€
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.log("æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥:", e));
            }

            let volume = 0.5;
            let oscillator = audioContext.createOscillator();
            let gainNode = audioContext.createGain();
            let now = audioContext.currentTime;
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // è®¾ç½®ä¸åŒéŸ³æ•ˆçš„éŸ³è‰²
            switch (type) {
                case SOUND_TANK_HIT: // å¦å…‹è¢«å‡»ä¸­
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_TANK_EXPLOSION: // å¦å…‹çˆ†ç‚¸
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(80, now);
                    oscillator.frequency.exponentialRampToValueAtTime(30, now + 1);
                    gainNode.gain.setValueAtTime(volume * 1.5, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1);
                    oscillator.start(now);
                    oscillator.stop(now + 1);
                    break;

                case SOUND_BRICK_HIT: // ç –å¢™è¢«å‡»ä¸­
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_BRICK_EXPLOSION: // ç –å¢™çˆ†ç‚¸
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_STEEL_HIT: // é’¢å¢™è¢«å‡»ä¸­
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(200, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;

                case SOUND_STEEL_EXPLOSION: // é’¢å¢™çˆ†ç‚¸
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, now);
                    oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.7);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.5);
                    break;

                case SOUND_SHOOT: // å°„å‡»éŸ³æ•ˆ
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(70, now + 0.2);
                    gainNode.gain.setValueAtTime(volume, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    break;
            }
        }

        // æ›´æ–°çŠ¶æ€æ 
        function updateStatusBar() {
            statusBar.textContent = `ç”Ÿå‘½: ${mytank.life} | æ•Œäºº: ${enemyTanks.length} | BOSSç”Ÿå‘½: ${boss ? boss.life : 0}`;
        }

        // è·å–canvasç”»å¸ƒå¯¹è±¡
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // è·å–æ¸¸æˆå…ƒç´ 
        const gameOverlay = document.getElementById('gameOverlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const joystickArea = document.getElementById('joystickArea');
        const statusBar = document.getElementById('statusBar');
        const soundToggle = document.getElementById('soundToggle');
        const fireButton = document.getElementById('fireButton');
        const dpadUp = document.getElementById('dpad-up');
        const dpadLeft = document.getElementById('dpad-left');
        const dpadRight = document.getElementById('dpad-right');
        const dpadDown = document.getElementById('dpad-down');

        // æŒ‰é”®ä¿¡æ¯
        let keys = {
            ArrowUp: false,
            ArrowRight: false,
            ArrowDown: false,
            ArrowLeft: false,
            Space: false
        };

        // é”®ç›˜äº‹ä»¶ç›‘å¬
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Space'].includes(e.code)) {
                e.preventDefault();
                if (e.code in keys) {
                    keys[e.code] = true;
                    if (keys.Space == true) {
                        let bullet = mytank.shoot();
                        if (bullet) {
                            myBullets.push(bullet);
                            playSound(SOUND_SHOOT);
                        }
                    } else {
                        mytank.updateDirection();
                    }
                }
            }

            // ESCé”®æš‚åœ/ç»§ç»­æ¸¸æˆ
            if (e.code === 'Escape') {
                e.preventDefault();
                gamePaused = !gamePaused;
                pauseOverlay.style.display = gamePaused ? 'flex' : 'none';

                // å¦‚æœæ¸¸æˆæš‚åœï¼Œåœæ­¢æ‰€æœ‰æ¸¸æˆé€»è¾‘ï¼›å¦‚æœæ¢å¤ï¼Œç»§ç»­æ¸¸æˆå¾ªç¯
                if (!gamePaused) {
                    lastFrameTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Space'].includes(e.code)) {
                e.preventDefault();
                if (e.code in keys) {
                    keys[e.code] = false;
                }
            }
        });

        // é‡å¯æŒ‰é’®äº‹ä»¶
        restartButton.addEventListener('click', resetGame);

        // éŸ³æ•ˆå¼€å…³
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
        });

        // åå­—é”®è§¦æ‘¸æ§åˆ¶
        function handleDirectionTouchStart(direction) {
            if (gamePaused) return;
            keys[direction] = true;
            mytank.updateDirection();
        }

        function handleDirectionTouchEnd(direction) {
            keys[direction] = false;
        }

        dpadUp.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadUp.classList.add('active');
            handleDirectionTouchStart('ArrowUp');
        });
        dpadUp.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadUp.classList.remove('active');
            handleDirectionTouchEnd('ArrowUp');
        });

        dpadLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadLeft.classList.add('active');
            handleDirectionTouchStart('ArrowLeft');
        });
        dpadLeft.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadLeft.classList.remove('active');
            handleDirectionTouchEnd('ArrowLeft');
        });

        dpadRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadRight.classList.add('active');
            handleDirectionTouchStart('ArrowRight');
        });
        dpadRight.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadRight.classList.remove('active');
            handleDirectionTouchEnd('ArrowRight');
        });

        dpadDown.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dpadDown.classList.add('active');
            handleDirectionTouchStart('ArrowDown');
        });
        dpadDown.addEventListener('touchend', (e) => {
            e.preventDefault();
            dpadDown.classList.remove('active');
            handleDirectionTouchEnd('ArrowDown');
        });

        // å°„å‡»æŒ‰é’®è§¦æ‘¸æ§åˆ¶
        fireButton.addEventListener('touchstart', function (e) {
            e.preventDefault();
            if (gamePaused) return;
            keys.Space = true;
            fireButton.classList.add('active');
            let bullet = mytank.shoot();
            if (bullet) {
                myBullets.push(bullet);
                playSound(SOUND_SHOOT);
            }
        });

        fireButton.addEventListener('touchend', function (e) {
            e.preventDefault();
            keys.Space = false;
            fireButton.classList.remove('active');
        });

        fireButton.addEventListener('contextmenu', function (e) {
            e.preventDefault();
        });

        // æ¸¸æˆå¯¹è±¡
        let bricks = [];
        let enemyTanks = [];
        let enemyBullets = [];
        let myBullets = [];
        let explosions = [];
        let boss = null;
        let mytank = new myTank(canvas.width / 2, canvas.height * 0.90);//å¦å…‹åˆå§‹ä½ç½®

        // åˆå§‹åŒ–æ¸¸æˆï¼ˆåœ¨å›¾ç‰‡åŠ è½½å®Œæˆåï¼‰
        loadImages().then(() => {
            bricks = generateBricks();
            enemyTanks = generate_enemytanks(ENEMY_TANK_AMOUNT);
            updateStatusBar();
            lastFrameTime = performance.now();
            gameLoop(lastFrameTime);
        });

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop(timestamp) {
            if (gamePaused) return;

            const deltaTime = timestamp - lastFrameTime;
            if (deltaTime < frameInterval) {//æ§åˆ¶æ¸¸æˆå¸§ç‡
                requestAnimationFrame(gameLoop);
                return;
            }
            lastFrameTime = timestamp - (deltaTime % frameInterval);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç –å—
            for (let brick of bricks) {
                brick.draw();
            }

            // ç»˜åˆ¶BOSS
            if (boss) {
                boss.draw();
            }

            // æ•Œæ–¹å¦å…‹éšæœºå°„å‡»
            for (let tank of enemyTanks) {
                const bullet = tank.randomShot();
                if (bullet) enemyBullets.push(bullet);
            }

            // æ›´æ–°å’Œç»˜åˆ¶æ•Œæ–¹å­å¼¹
            for (let j = 0; j < enemyBullets.length; j++) {
                enemyBullets[j].move();
                enemyBullets[j].draw();

                // æ£€æµ‹å­å¼¹ä¸æˆ‘æ–¹å¦å…‹ç¢°æ’
                if (checkCollision(enemyBullets[j], mytank)) {
                    enemyBullets[j].life = false;
                    //enemyBullets.splice(j, 1);
                    mytank.life--;
                    mytank.hit();
                    playSound(SOUND_TANK_HIT);
                    if (mytank.life <= 0) {
                        explosions.push(new Explosion(mytank.center_x, mytank.center_y));
                        playSound(SOUND_TANK_EXPLOSION);
                    }
                    updateStatusBar();
                    break;
                }

                // æ£€æµ‹å­å¼¹ä¸BOSSç¢°æ’
                if (boss && checkCollision(enemyBullets[j], boss)) {
                    enemyBullets[j].life = false;
                    enemyBullets.splice(j, 1);
                    boss.hit();
                    playSound(SOUND_TANK_HIT);
                    updateStatusBar();
                    break;
                }

                // æ£€æµ‹å­å¼¹ä¸ç –å—ç¢°æ’
                for (let i = bricks.length - 1; i >= 0; i--) {
                    if (checkBulletBrickCollision(enemyBullets[j], bricks[i])) {
                        enemyBullets[j].life = false;
                        enemyBullets.splice(j, 1);
                        bricks[i].hit();

                        if (bricks[i].type === BRICK_TYPE_EARTH) {
                            playSound(SOUND_BRICK_HIT);
                        } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                            playSound(SOUND_STEEL_HIT);
                        }

                        if (bricks[i].life <= 0) {
                            explosions.push(new Explosion(bricks[i].left + bricks[i].width / 2, bricks[i].top + bricks[i].height / 2, true));

                            if (bricks[i].type === BRICK_TYPE_EARTH) {
                                playSound(SOUND_BRICK_EXPLOSION);
                            } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                                playSound(SOUND_STEEL_EXPLOSION);
                            }

                            bricks.splice(i, 1);
                        }
                        break;
                    }
                }
            }

            // æ›´æ–°å’Œç»˜åˆ¶æˆ‘æ–¹å­å¼¹
            for (let j = 0; j < myBullets.length; j++) {
                myBullets[j].move();
                myBullets[j].draw();

                // æ£€æµ‹æˆ‘æ–¹å­å¼¹ä¸æ•Œæ–¹å¦å…‹ç¢°æ’
                for (let i = enemyTanks.length - 1; i >= 0; i--) {
                    if (checkCollision(myBullets[j], enemyTanks[i])) {
                        myBullets[j].life = false;
                        myBullets.splice(j, 1);
                        enemyTanks[i].life--;
                        enemyTanks[i].hit();
                        playSound(SOUND_TANK_HIT);
                        if (enemyTanks[i].life <= 0) {
                            explosions.push(new Explosion(enemyTanks[i].center_x, enemyTanks[i].center_y));
                            enemyTanks.splice(i, 1);
                            playSound(SOUND_TANK_EXPLOSION);
                            updateStatusBar();
                        }
                        break;
                    }
                }

                if (j >= myBullets.length) continue;//å­å¼¹ç¢°æ’åï¼ŒmyBulletsåˆ—è¡¨å·²ç¼©çŸ­

                // æ£€æµ‹æˆ‘æ–¹å­å¼¹ä¸ç –å—ç¢°æ’
                for (let i = bricks.length - 1; i >= 0; i--) {
                    if (checkBulletBrickCollision(myBullets[j], bricks[i])) {
                        myBullets[j].life = false;
                        //myBullets.splice(j, 1);æ­¤å¤„ä¸èƒ½ç•™ï¼Œå¦åˆ™å­å¼¹å‡»ä¸­å¢™å£åï¼Œä¸‹é¢æ£€æµ‹æˆ‘æ–¹å­å¼¹ä¸BOSSç¢°æ’æ—¶ä¼šæç¤ºé”™è¯¯ã€‚
                        bricks[i].hit();

                        if (bricks[i].type === BRICK_TYPE_EARTH) {
                            playSound(SOUND_BRICK_HIT);
                        } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                            playSound(SOUND_STEEL_HIT);
                        }

                        if (bricks[i].life <= 0) {
                            explosions.push(new Explosion(bricks[i].left + bricks[i].width / 2, bricks[i].top + bricks[i].height / 2, true));

                            if (bricks[i].type === BRICK_TYPE_EARTH) {
                                playSound(SOUND_BRICK_EXPLOSION);
                            } else if (bricks[i].type === BRICK_TYPE_STEEL) {
                                playSound(SOUND_STEEL_EXPLOSION);
                            }

                            bricks.splice(i, 1);
                        }
                        break;
                    }
                }

                // æ£€æµ‹æˆ‘æ–¹å­å¼¹ä¸BOSSç¢°æ’ï¼ˆæˆ‘æ–¹å­å¼¹ä¸æ‘§æ¯BOSSï¼Œä½†ä¸è¶Šè¿‡BOSSï¼‰
                if (boss && checkCollision(myBullets[j], boss)) {
                    myBullets[j].life = false;
                    myBullets.splice(j, 1);
                    break;
                }
            }

            // æ›´æ–°å’Œç»˜åˆ¶æ•Œæ–¹å¦å…‹
            for (let tank of enemyTanks) {
                tank.randomMove();
                tank.draw();
            }

            // æ›´æ–°å’Œç»˜åˆ¶æˆ‘æ–¹å¦å…‹
            if (mytank.life > 0) {
                mytank.move();
                mytank.draw();
            }

            // æ›´æ–°å’Œç»˜åˆ¶çˆ†ç‚¸åŠ¨ç”»
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].draw();
                explosions[i].update();
                if (!explosions[i].active) {
                    explosions.splice(i, 1);
                }
            }

            // ç§»é™¤æ­»äº¡çš„å­å¼¹
            removeDeadObjects(enemyBullets);
            removeDeadObjects(myBullets);

            // æ¸¸æˆç»“æŸæ£€æµ‹
            if (mytank.life <= 0) {
                messageText.textContent = 'æ¸¸æˆç»“æŸ';
                messageText.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.8)';
                gameOverlay.style.display = 'flex';
                return;
            }

            // èƒœåˆ©æ£€æµ‹
            if (enemyTanks.length == 0) {
                messageText.textContent = 'èƒœåˆ©!';
                messageText.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.8)';
                gameOverlay.style.display = 'flex';
                return;
            }

            // BOSSè¢«å‡»ä¸­2æ¬¡åæ¸¸æˆç»“æŸ
            if (boss && boss.life <= 0) {
                explosions.push(new Explosion(boss.x, boss.y));
                boss = null;
                messageText.textContent = 'BOSSè¢«æ‘§æ¯!';
                messageText.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.8)';
                gameOverlay.style.display = 'flex';
                return;
            }

            requestAnimationFrame(gameLoop);
        }
    </script>
</body>

</html>